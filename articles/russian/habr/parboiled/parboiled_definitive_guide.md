# Все, что вы хотели знать о Parboiled

Сегодня, в свете бурного роста популярности функциональных языков, всё чаще находят применение комбинаторы парсеров — 
подход, облегчающий разбор текста простым смертным. Такие инструменты, как Parsec (Haskell) и Planck (OCaml) уже успели
хорошо себя зарекомендовать в своих экосистемах. Их удобство и востребованность в своё время подтолкнули создателя
языка Scala, Мартина Одерски, внести в стандартную библиотеку их аналог — Scala Parser Combinators
(ныне вынесены в scala-modules), а знание и умение пользоваться подобными инструментами — отнести к обязательным
требованиям к Scala-разработчикам [уровня A3](http://www.scala-lang.org/old/node/8610).

Эта статья посвящена библиотеке Parboiled — мощной альтернативе и возможной замене для Scala Parser Combinators.
Мы подробно рассмотрим работу с текущей версией библиотеки — Parboiled2, а также уделим внимание Parboiled1,
так как большая часть существующего кода всё ещё использует именно её. Мы затронем следующие вопросы:

 - Введение в Parboiled2 от простого к сложному.
 - Миграция с первой на вторую версию библиотеки.
 - Подводные камни Parboiled1 и Parboiled2.
 - Паттерны и best-practices™ при написании парсеров.

Итак, всех заинтересовавшихся прошу под кат.

------------------------------------------------------------------------------------------------------------------------

Parboiled - библиотека позволяющая вам с легкостью разбирать (парсить) языки разметки (такие как HTML, XML или JSON),
конфигурационные файлы, логи, языки программирования, текстовые протоколы и многое другое. Если вы хотите спроектировать
свой предметно-ориентированный язык ([DSL](https://en.wikipedia.org/wiki/Domain-specific_language)) Parboiled тоже
придет вам на помощь. Вы сможете получить древовидное представление вашей предметной области. Или используя
интерпритатор, исполнять команды вашего доменного языка.


## Основные фичи Parboiled2
  - Parboiled основан на [PEG](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
  - Parboiled геренирует однопроходные парсеры. Лексер не требуется.
  - Используется DSL являющися подмножеством языка scala.
  - Оптимизации выполняются на этапе компиляции


## Почему Parboiled
  - Вам не нужно писать парсер голыми руками.
  - Так как parboiled основан на PEG. Это позволяет разбирть рекурсивные структуры данных (регулярные выражения не могут
    это по определению). Да, регулярными выражениями вы не распарсите JSOn или даже простенький калькулятор (чего уж
    говорить о языках программирования).
    
        Parse arbitrary HTML is like asking Paris Hilton to write an operating system.
        
  - Читаемость сравнимая с различными сортами bnf (по моему мнению даже и лучше). 
  - Даже если вам нужно разобрать линейную (нерекурсивную структуру) parboiled2 (при использовании должных оптимизаций)
    будет работать быстрее регулярных выражений.
    [Пруф](https://groups.google.com/forum/#!msg/parboiled-user/XATcJRLTXjA/XSmf3n6gZSwJ)

        Бенчмарк:
          parboiled2 (warmup): 1621.212ms
          parboiled2: 409.162ms
          parboiled2 with better types (warmup): 488.919ms
          parboiled2 with better types: 134.676ms
          regex (warmup): 621.95ms
          regex: 620.379ms

  - В отличии от генераторов парсеров, таких как Antlr вы освобождены от (как бы это банально не звучало) генерации java
    кода парсера, который надо в последствии скармливать компилятору. Весь код в parboiled пишется на scala, поэтому вы
    получаете подсветку синтаксиса и проверку типов из коробки, а так же отсутствие дополнительных операций над файлами
    грамматик.

  - Скаловские парсер-комбинаторы почти идеальны, если вас не смущает скорость их работы. Я не проводил оценку
    производительности, однако Matias Doenitz (один из разработчиков библиотеки) проводил. Согласно его данным:
    
      * parboiled1 быстрее чем parser-сombinators
      * parboiled2 быстрее чем parboiled1
      * 'быстрее чем' транзитивно :)

  - В отличии от Language Workbenches, Parboiled это маленькая и простая в использовании библиотека. Вам не нужно
    скачивать плоходокументированного и тормозящего монстра, тратить часы драгоценной жизни на изматывающее общение с
    UI: поиск нужных менющек и кнопочек, всего-навсего для построения небольшого DSL. Да, вы не получите на все готоый
    текстовый редактор из коробки, и возможно вам придется самостоятельно писать плагины для текстовых редакторов.
    Однако parboiled вполне достойная альтернатива для маленьких предметно-ориентированных языков.

  - parboiled успешн зарекомендовал себя во 
    [многих проектах](https://github.com/sirthias/parboiled/wiki/Projects-using-parboiled).

  Небольшой benchmark проведенный Александром Мыльцевым (разработчиком библиотеки) взято 
  [отсюда](http://myltsev.name/ScalaDays2014/#/), показывает что скорость разбора приближается к "древним магическим
  парсерам эльфийскйо работы".

### Parboiled2 vs handwritten Json parsers
  
                  бенчмарк    ms linear runtime
      Parboiled1JsonParser 85.64 ==============================
      Parboiled2JsonParser 13.17 ====
                  Argonaut  7.01 ==
              Json4SNative  8.06 ==
             Json4SJackson  4.09 =


## Новые возможности Parboiled2

  - Parboiled2 решает ряд проблем присущих первой версии
    * Решена так называемая Rule7-problem. Для этого была использована библиотека shapeless с ее знаменитыми HListами
      Теперь одно правило может оперировать большим количеством значений на стеке.
    * Добавлены недостающие конструкции. Pb1 нельзя было указать динамическое количество повторений для nTimes. Для
      этого приходилось использовать
      правило oneOrMore, Что не давало требуемой точности при описании грамматики.
    * Встроенные примитивные терминалы. Появился класс CharPredicate, который содержит такие поля как AlphaNumeric, Hex,
      Printable, Visible и другие. Многие пользователи pb1 писали стандартную библиотеку.
    * Добавлена возможность расширения и сужения предиката. Раньше возникала потребность исключить несколько символов из
      правила. Например нам нужны все видимые символы, кроме '=' и ']'. Теперь это с легкостью можно сделать. А не
      создавать "белый список" символов.
  - Parboiled2 использует дополнительную зависимость: библиотеку shapeless.
  - Parboiled2 использует макросы, это позволяет генерировать грамматику на этапе компиляции, а не в рантайме, как это
    сделано для parboiled1. Это многократно увеличивает производительность вашего парсера, и увеличивает количество
    проверок. В связи с этим блок 'rule' стал обязательным. В некоторых случаях код корректно работает без него.
    Теперь это не так.
  - Поддержка scala.js. Демо проект представел [здесь](https://github.com/alexander-myltsev/parboiled2-scalajs-samples).
  - Поддержка [Base64 строк]
   (https://github.com/sirthias/parboiled2/blob/v2.0.0-RC1/parboiled/src/main/scala/org/parboiled2/Base64Parsing.scala).


Как работать с библиотекой
==========================



Наиболее распространенные паттерны
==================================

Квотированные строки
====================
-----------------------
-----------------------
-----------------------
TODO

Парсер на сайдэффектах
======================
------------------------
------------------------
------------------------
TODO


Best practices
==============


  Отправляйте case objects вместо строк в Value stack
  ===================================================
  Отправляйте в Value stack значимые объекты, а не строки.
  Пример

  Плохо:

      def logLevel = rule {
        capture("info" | "warning" | "error") ~ ':’
      }

  Хорошо:

      def logLevel = rule {
          “info:” ~ push(LogLevel.Info)
        | “warning" ~ push(LogLevel.Warning)
        | “error" ~ push(LogLevel.Error)
      }





Оптимизации
===========

  Развертка n.times для n <= 4
  ============================
  Вы можете выиграть в производительности если вместо правила "times" для маленьких n

      rule { 4 times CharPredicate.Digit }

  будете использовать правило "sequence"

      import CharPredicate.Digit
      rule { Digit ~ Digit ~ Digit ~ Digit }

  Это связано в существующей на момент публикации данной статьи существует проблемой: [[https://github.com/sirthias/parboiled2/issues/101]]


  Ускорение операций со стеком для nTimes
  =======================================
  Использование подобной оптимизации при извлечении чисел со стека тоже позволит вам выжать немножко производительности

      def digit4 = rule {
        Digit ~ Digit ~ Digit ~ Digit ~ push(#(charAt(-4)) * 1000 + #(charAt(-3)) * 100 + #(charAt(-2)) * 10 + #(lastChar))
      }


  Используйте ANY, там где хотите видеть CharPredicate.All
  ========================================================
  TODO:


  Используйте инвертирующий предикат ??
  =====================================
  TODO:

  ------------------
  ------------------
  ------------------
  TODO


  И помните, оптимизации должны быть своевременными :).


Использованные источники
========================
 * Юзергруппа посвященная Parboiled2 [[https://groups.google.com/forum/#!topic/parboiled-user/Ygb_M6XU5P8]]
   Здесь вы можете задать все интересующие вас вопросы. Вам помогут.
 * Презентация Александра Мыльцева [[http://www.youtube.com/watch?v=qZg4D62K4aQ]]
 * Слайды [[http://myltsev.name/ScalaDays2014/#/]]
 * Официальная документация [[https://github.com/sirthias/parboiled2/blob/master/README.rst]]
 * Примеры исходного кода [[https://github.com/sirthias/parboiled2/tree/master/examples/src/main/scala/org/parboiled2/examples]]

