# Про Parboiled
**Часть 3: Извлечение данных**
В этой стать

<cut text="Читать про написание парсера →">

### Стек значений (Value Stack)

Прежде чем извлекать какие-либо данные при помощи правил, следует немного рассказать про одну из концепций,
использующихся в Parboiled. Она называется Value Stack и её можно не совсем корректно перевести как «стек значений»
(как будто кому-то нужны стеки без значений). Представляет он собой, действительно, стек, который модифицируется
*действими парсера* (parser actions), в него помещаются и из него извлекаются результаты парсинга правил. Именно
этому самому стеку мы должны дать подсказку при объявлении рекурсивных правил. Для того, чтобы элементы были помещены
на стек, их необходимо явно захватить, что отразится на виде ваших правил. Типы правил так же отражают количество
захваченных элементов и их тип. Элементы стека могут иметь разный тип, а типизация стека значений проверяется на
этапе компиляции.

### Типы правил

В Parboiled2 существуют следующие типы правил:

 - `Rule0` — просто отвечает на вопрос "Сопоставилось ли?", не изменяя содержимое стека.
 - `Rule1` — помещает один объект в стек значений.
 - `Rule2` — помещает два объекта в стек значений.
 - `RuleN` — помещает N объектов в стек значений, используя семантику библиотеки Shapeless. Для работы с Parboiled2
   знать Shapeless не нужно (хотя и будет полезно).
 - `PopRule` — извлекает значения со стека, не помещая туда новых значений.

При желании можно объявить свои псевдонимы для типов, как это было в Parboiled1. Например, так в коде Parboiled2
реализуется реализуется `Rule2`:

    type Rule2[+A, +B] = RuleN[A :: B :: HNil]

В Parboiled1 для каждого количества аргументов от 0 до 7 существовало по отдельному типу, что создавало так называемую
«проблему `Rule7`»: класса `Rule8` уже нет и положить восемь элементов в стек значений не получится, даже если очень
сильно хочется. Существуют различные пути для обхода этой проблемы, про один из них я расскажу далее в статье.


### Действия парсера (parser actions)

Действия на парсерах стоило бы назвать действиями над стеком, так как они позволяют извлекать данные из
сопоставившихся правил и преобразовывать их, а при условии высокой степени вашей испорченности — и производить с ними
сайд-эффекты (что может быть в некоторых случах действительно необходимо, например если размер и количество извлекаемых
данных заранее не известны). С помощью действий можно формировать абстрактные синтаксические деревья ([AST][ast]), их
можно использовать для вычисления «на месте», как это сделано в [примере с калькулятором](calc).

[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[calc]: http://bit.ly/1iJg7zP


## Захватывающие истории

Чтобы совершить какое-то полезное дейстие над данными, нам надо их сначала захватить. Для этого существует
функция `capture`: она сопоставляет данные с правилом и в случае успеха помещает их на стек значений.

Предположим у нас есть правило типа `Rule0`, из которого мы хотим хоть что-то вытащить:

    def User: Rule0 = rule { FirstName ~ Separator ~ LastName }

Нам нужно решить, что именно мы будем захватывать, хотя очевидно, что разделитель не представляет художественной
ценности:

    def User: Rule2[String, String] = rule {
      capture(FirstName) ~ Separator ~ capture(LastName)
    }

С этого момента наше правило уже не `Rule0`, а `Rule2`, так как оно захватывает и оправляет в стек значений две
строки. Впрочем, в нашем простом случае тип можно было и не указывать, компилятор всё поймет сам.


### Оператор действия (~>)

... или оператор, которым вам придётся пользоваться чаще всего. В качестве правого параметра принимает лямбду, на вход
которой отправляет прямо со стека захваченные объекты и тем самым позволяет лямбде с этими объектами работать. Потом,
при желании, значения можно отправить обратно в стек, или же создать из них ноду для вашего AST, выберите по своему
вкусу. В любом случае, для того чтобы действие осуществилось, нужно предватительно выполнить захват данных на стек при
помощи функции `capture`. В завимисости от типа возвращаемого значения используются различные формы оператора (~>),
что делает использование данного оператора простым и интуитивным.

> **Легаси:** В Parboiled1 захват выполнялся неявно, что мне кажется весьма неудобным.

Теперь немного подробнее про лямбду. Её сигнатура зависит от количества и типизации захваченных объектов, причём за раз
лямбда может захватить [не более 22 аргументов][lambda22]. Типы аргументов лямбды соответствую типам значений, снимаемых
со стека, а типы возвращаемых значений — типам значений, помещаемых назад в стек.

[lambda22]: https://github.com/sirthias/parboiled2/issues/85

Для примера попробуем вырвать у парсера хотя бы одно целое число:

    def UnsignedInteger: Rule1[Int] = rule {
      capture(Digit.+) ~> (numStr => numStr.toInt)
    }

В этой ситуации поощряется использование фирменного скаловского плейсходера:

    def UnsignedInteger: Rule1[Int] = rule { capture(Digit.+) ~> (_.toInt) }

Здесь наша лямбда имеет тип `(String => Int)`, что обуславливает тип нашего правила `Rule1[Int]`. Позволяется применять
оператор (~>) и к типизированному правилу, например, следующее правило сматчит целое число, но поместит в стек не его,
а его утроенное значение:

    def TripleInt = UnsignedInteger ~> (i => i * 3)

Тип правила `TripleInt` так и останется `Rule1[Int]`, только вот на стеке будет лежать другое значение.

> **Хинт:** Явно указывать тип тип аргументов лямбда-функции есть не очень хорошая идея (по крайней мере, на момент
> написания статьи). В компиляторе Scala существует весьма неприятный баг, который не даст вашему коду нормально
> скомпилироваться.

С одним аргументом мы разобрались, но что делать, если их несколько? Как поведет себя лямбда? Просто и предсказуемо:
первый параметр соответствует самому верхнему значению на стеке, второй параметр — второму сверху, и так далее.
Так как процедура захвата подвыражений выполняется *справа налево*, то порядок аргументов лямбда-функции соответствует
порядку записи операций захвата:

    def UserWithLambda: Rule2[String, String] = rule {
      (capture(FirstName) ~ Separator ~ capture(LastName)) ~> ((firstName, lastName) => ...)
    }

Благодаря оператору действия мы можем уменьшать количество значений на стеке:

    def UserName = User ~> ((firstName, lastName) => s"$firstName $lastName")

В приведённом примере исходный тип правила `User` был `Rule2[String, String]`, применив к нему лямбда-функцию мы
создали новое правило `UserFirstName` с типом `Rule1[String]`.

Лямбда не обязанна принимать *все* параметры со стека, можно вполне ограничиться последними N значениями (помним, что
лямбда забирает аргументы с конца стека):

    def bar = (foo: Rule2[Int, String]) ~> (_.toDouble)
    // bar: Rule2[Int, Double].

Ничего не мешает нам попробовать скормить правилу лямбда-функцию, не имеющую аргументов, с предсказуемым результатом:

    def bar = (foo: Rule2[String, Int]) ~> (() => 42)
    // bar: Rule2[String, Int].

Однако, у Parboiled2 есть более мощные инструменты, такие как возможность вернуть из лямбды на стек сразу группу
значений, используя для этого `HList` из библиотеки Shapeless:

    def bar = (foo: Rule1[Event]) ~> (e => e::DateTime.now()::"localhost"::HNil)
    // bar: RuleN[Event::DateTime::String::HNil]

Также можно забирать из стека значения, ничего не давая взамен: для этого лямбда всего-навсего должена «возвращать»
тип `Unit`. Типом получившегося правила, как вы наверное догадались, будет `Rule0`:

    def bar = (foo: rule1[String]) ~> (println(_))
    // bar: Rule0

Кроме того, оператор действия предлагает особо сладкий сахар для case-классов:

    case class Person(name: String, age: Int)

    def bar = (foo: Rule2[String, Int]) ~> Person
    // bar: Rule1[Person]

Правда нужно отметить, что компилятор может и не переварить этот сахар, если для case-класса определён companion object.
Тогда придётся добавить лямбду и немного подчёркиваний и записать: `~> (Person(_, _))`.

Сахар для case-классов идеально подходит для построения AST, опытные пользователи могут даже заметить, что в этом случае
он работает совершенно аналогично оператору `~~>` из Parboiled1. Существуют и другие способы применения этой волнистой
стрелочки, но о них вы узнаете не от меня, а из документации. Отмечу только, что оператор `~>` реализуется в коде
Parboiled2 весьма нетривиальным образом, но как бы сложно не выглядело его определение, пользоваться им просто и
интуитивно.


### run

Особая версия оператора действия для любителей острых ощущений. Для программиста во многих отношениях `run` ведёт себя
точно так же, как и `(~>)`, кроме того маленького неудобства, что в случае с `run` компилятор не выводит типы
автоматически и их придётся обозначить явно. Но это делает его очень удобным для создания непроверяемых сайд-эффектов,
например как здесь:

    import sys.process._

    def RuleWithSideEffect = rule {
      capture(ANY.*) ~> run { s: String => "sudo rm -rf /" ! }
    }

Типом результирующего правила будет `Rule0`, а сопоставленная строка вовсе никому не нужна и ни в какой стек значений
не попадёт, что иногда бывает необходимо. Пользователи Parboiled1 наверное заметили, что в `run` ведет себя так же,
как оператор `(~%)`.

> **Предупреждение:** При использовании сайд-эффектов, пожалуйста, не заигрывайте со стеком значений. Да, к нему можно
> прямой доступ, но по ряду причин этого лучше не делать.


### push

Функция `push` помещает данные на стек значений в случае, если соответствующее ему правило сопоставилось. На практике
мне не приходилось пользоваться им часто, так как большую часть работы может выполнить оператор `(~>)`, но существует
пример, в котором `push` просто блистает:

    sealed trait Bool
    case object True extends Bool
    case object False extends Bool

    def BoolMatch = rule { "true" ~ push(True) | "false" ~ push(False) }

> **Хинт:** Хоть это нигде и не помеченно, данное правило следует семантике call-by-name и вычисляется каждый раз, а
> значит и его аргумент вычисляется каждый раз. Обычно это не очень хорошо для производительности, поэтому `push` лучше
> использовать с константами и только c константами.

Так же как в случае с `run` и `~>`, тип значения, переданного в `push`, определяет содержимое стека и тип создаваемого
правила.


### Вложенные парсеры

В Parboiled2 существует подежрка вложенных парсеров: захватывая текст и скармливая его оператору `~>` мы получаем
переменную строкового типа в качестве параметра лямбда функции. Проведя некоторые операции со сторокой мы можем скормить
ее какому-нибудь подпарсеру и так далее. На практике применять не приходилось, однако знайте, что такая возможность
есть.


## Генерация AST

У нас есть все необходимые знания, чтобы написать свой парсер, генерирующий синтактическое дерево. Синтаксические
деревья сторятся из нод (да-да из тех нод что мы описывали в правилах). Поэтому начнем с них, вернее с их описания:

    sealed trait AstNode
    case class KeyValueNode(key: String, value: String) extends AstNode
    case class BlockNode(name: String, nodes: Seq[AstNode]) extends AstNode

Каждый из кейс классов соответствует определенному типу ноды, вроде бы все ясно и понятно. Однако давайте постараемся
найти что-то общее среди приведенных выше узлов. У каждого есть имя, просто в случае с парой ключ-значение это ключ.
Узлы между собой различать тоже как-то нужно.

    sealed trait AstNode {
      def name: String
    }

    case class KeyValueNode
    (override val name: String, value: String) extends AstNode

    case class BlockNode
    (override val name: String, nodes: Seq[AstNode]) extends AstNode

Начнем с узла для пар ключ-значение. Собственно нам нужно захватить ключ, заватить значение и собрать это все в case
class посредством оператора `~>`. Захват мы будем делать "на месте" (в правилах для Ключа и Значения). И начнем мы с
ключа:

    // Можно довериться выводу типов и не указывать тип явно
    def Key: Rule1[String] = rule { capture(oneOrMore(KeySymbol)) }

Просто добавляем `capture` и все - Parboiled думает о нас. Строка будет отправлена на стек. А вот с захватом значения
ситуация будет поинтересней. Если мы провернем операцию, аналогичную для ключа, нам придет строка с кавычками. Они нам
нужны? Поэтому захват будем делать на территории строки:

    def QuotedString: Rule1[String] = rule {
      '"' ~ capture(QuotedStringContent)  ~ '"'
    }

Для правила Value ничего делать не нужно, оно автоматически будет иметь тип Rule1 (так как тело строки было захвачено
ранее, со стека оно никуда не ушло).

>Захват `capture` нужно делать один раз. И желательно, в том правиле где он должен был произойти

Теперь соберем case class:

    def KeyValuePair: Rule1[AstNode] = rule {
      Key ~ MayBeWS ~ "=" ~ MayBeWS ~ Value ~> KeyValueNode
    }

Используем синтаксический сахар и элегантно упаковывам полученные ключ и значение в подходящую ноду. Конечно же мы можем
использовать расширенный лямбда-синтаксис и выполнить какие-либо преобразования. Но нам они не нужны :).
Теперь разберемся со списком нод:

    // тип должен быть объявлен явно, даже если вы полагаетесь на компилятор
    def Node: Rule1[AstNode] = rule { KeyValuePair | Block }

Так как каждая из нод захвачена правило `Nodes` изменений не требует, разве что стоит указать тип значения помещаемого
на стек:

    def Nodes: Rule1[Seq[AstNode]] = rule {
      MayBeWS ~ zeroOrMore(Node).separatedBy(NewLine ~ MayBeWS) ~ MayBeWS
    }

У нас есть все для описания Блочной ноды. Имя захватим на месте, аналогично правилу для ключа:

    def BlockName: Rule1[String] = rule { capture(oneOrMore(BlockNameSymbol.+)) }

Ноды уже были захвачены, поэтому просто соберем данные в case class:

    def Block: Rule1[AstNode] = rule {
      BlockName ~ MayBeWS ~ BlockBeginning ~ Nodes ~ BlockEnding ~> BlockNode
    }

Правило, описывающее корень дерева так же состоит из нод, поэтому можно ничего больше и не делать. И вроде бы все
работает хорошо и ничего менять не хочется, однако результат выглядит не очень красиво: у нас есть два типа нод, и
корень который представляет список нод. И третий явно лишний. Мы можем представить корень в качестве блока, с особым
именем.

    def Root: Rule1[AstNode] = rule {
      Nodes ~ EOI ~> {nodes: Seq[AstNode] => BlockNode(RootNodeName, nodes)}
    }

Какое имя выбрать? Мы можем дать блоку вполне осознаное имя, например root, но тогда нас могут ждать непредвиденные
сюрпризы, если кто-то захочет выбрать имя root. Зная что BlockName является идентификатором, поэтому не допускает ряда
символов можно попробовать имена вроде "$root", "!root!" или "%root%". Работать будет. Я предпочту пустую строку:

    val RootNodeName = ""

Пустая строка:

 - Удовлетворяет главному требованию - не является валидным именем блока или ключа
 - Отлично подойдет если мы захотим расширить грамматику. Как бы мы не мурыжили парсер, уж что-что а пустую строку
 пользователь точно не создаст.

Теперь у нас есть захваченные данные. Остается только выполнить прогон из корня для подходящего текста.
Еще раз напомню, что с кодом проекта вы можете ознакомиться [здесь](https://github.com/ppopoff/parboiled-talk).


## DSL для работы с узлами

Получив на руки рабочий парсер, способный отдавать синтаксическое дерево, мы должны с этим деревом как-то работать.
Создание небольшого DSL значительно упрощает эту задачу. Например, нам нужно перейти к следующей ноде по имени.
Можно каждый каждый раз писать один и тот же код, а можно сделать небольшой метод (продублированный перегруженным
оператором), способный возвращать следующую ноду. Ниже приведены основные методы необходимые для работы с AstNode.
На базе этих методов можно сделать много других (наиболее подходящих под ваши нужды). Если захотите можете дать им
символьные имена и любоваться красотой полученного DSL.

    /**
     * Код имеющий крайне опосредованное отношение к parboiled
     */
    trait NodeAccessDsl { this: AstNode =>

      def isRoot = this.name == BkvParser.RootNodeName

      lazy val isBlockNode = this match {
        case _: KeyValueNode => false
        case _ => true
      }

      /**
       * В случае блокового узла возвращает список вложенных пар
       * ключ-значение
       */
      def pairs: Seq[KeyValueNode] = this match {
        case BlockNode(_, nodes) =>
          nodes collect { case node: KeyValueNode => node }
        case _ => Seq.empty
      }

      /**
       * В сдучае блокового узла возвращает спосок вложеных
       * блоков
       */
      def blocks: Seq[BlockNode] = this match {
        case BlockNode(_, nodes) =>
          nodes collect { case node: BlockNode => node }
        case _ => Seq.empty
      }

      /**
       * Значение в случае пары "ключ-значение"
       */
      def getValue: Option[String] = this match {
        case KeyValueNode(_, value) => Some(value)
        case _ => None
      }
    }

Хочу отметить что лишних методов не бывает, и практически каждый раз требуются: рекурсивный поиск, возможность изменять
значения в нодах (изменяя состояние, либо используя
[линзы](http://stackoverflow.com/questions/8307370/functional-lenses)). Наличие разнообразных вспомогательных методов
работающих с деревом очень сильно упрощает жизнь.



------------------------------------------------------------------------------------------------------------------------
Про Parboiled
=============
**Часть 4. Суровая действительность**

## Отчеты об ошибках

Не думаю, что вам захочется работать с парсером, выдающем сообщение «Syntax error» при любых некорректных входных
данных. Parboiled2 способен вполне внятно рассказывать об ошибках, если вы ему в этом поможете.


### Форматирование

Итак, если что-то где-то навернулось, парсер передаст в ваше распоряжение объект типа `ParseError`, который можно
привести в читаемый вид посредством метода `formatError` *самого парсера*:

    val errorMessage = parser formatError error

Если дефолтное форматирование вас по каким-то причинам не устраивает, свои пожелания следует явным образом передать
передать парсеру в опционального параметра метода `formatError`:

    val errorMessage parser.formatError(error, new ErrorFormatter(showTraces = true))

Правда, если вы захотите написать свой `ErrorFormatter`, вам придётся самостоятельно разобраться со структурой
класса `ParseError`, который объявлен в глубине Parboiled таким образом:

    case class ParseError(position: Position, charCount: Int, traces: Seq[RuleTrace]) extends RuntimeException

Также стоит отметить наличие нескольких схем доставки сообщений об ошибке до заказчика: по вашему желанию `ParseError`
может быть представлен не только в виде объекта `Try`, а, например, в виде полиморфного типа или `Either`. Подробнее
можно ознакомиться [в ридми][deliv].

[deliv]: https://github.com/sirthias/parboiled2/blob/master/README.rst#alternative-deliveryschemes

    def Foo = rule { "foo" | fail("Я упаль!") }


### Тонкая настройка

Прежде всего, всегда есть опция, позволяющая обойти встроенный механизм формирования сообщений об ошибках. Для этого
всего-то нужно использовать правило `fail` с тем сообщением, с каким вы пожелаете:

    def Goldfinger = rule { "talk" | fail("to die") }

Тогда при удобном случае вы получите назад своё сообщение об ошибке, примерно в такой форме:

    `Invalid input 'Bond', expected to die. (line 1, column 1):`


### Именованные правила

Использование их бывает весьма полезным не только в целях отлова ошибок. Использование этого механизма описано ниже
в разделе «Best Practices».


### atomic

Parboiled2 создаёт парсер, построенный на PEG. Это означает что он работает на уровне символов, а не строк (как многие
могли подумать), поэтому и ошибки вам будут показываться на символьном уровне. Согласитесь, сообщение вида
«У вас тут X, мы ожидали Y или Z» потребует больше мысленных усилий, чем «У вас тут XX, а мы ожидали увидеть XY
или XZ». Для того, чтобы видеть строки в отчетах об ошибках целиком, придуман маркер `atomiс`, всего-то и нужно
обернуть в него правило:

    def AtomicRuleTest = rule { atomic("foo") | atomic("fob") | atomic("bar"beggyatwork) }

Чтобы при лисичках на входе получить

    Invalid input "fox", expected "foo", "fob" or "bar" (line 1, column 1):
    foxes
    ^


## quiet

Когда вариантов для выбора слишком много, не хочется показывать в сообщении об ошибке их все. Например в определенном
месте ваш парсер ожидает множество пробельных символов в совокупности с неким правилом. Для устранения избыточности
в отчете, вы, возможно, захотите умолчать о пробелах. С использованием маркера `quiet` это очень просто:

    def OptionalWhitespaces = rule { quiet(zeroOrMore(anyOf(" \t\n"))) }

Честно признаюсь, ситуаций, поощряющих использования этого правила, я не встречал. Так же, как и `atomic`, оно
подробно [описано в документации][doc-quiet].

[doc-quiet]: https://github.com/sirthias/parboiled2/blob/master/README.rst#the-quiet-marker


## Восстановление после ошибок

Это, практически, единственный эпизод, где Parboiled1 выигрывает. В PB2 дела обстоят не очень хорошо: парсер падает уже
только от вида первой же встреченной им ошибки. Для большинства сценариев это отлично подходит: это, например, не мешает
парсить конфигурационные файлы (не имеет смысла начинать работу с невалидным конфигом), однако разработчикам DSL или
IDE-подобных инструментов такое положение дел будет не по душе. [Маттиас обещает когда-нибудь это исправить][issue-42],
поэтому если вам эта фича очень сильно нужна уже сейчас — пните баг-трекер посильнее, вдруг это ускорит процесс
разработки.

[issue-42]: https://github.com/sirthias/parboiled2/issues/42

В Parboiled1 есть целая [куча ParserRunnerов][runners] на все случаи жизни, посмотрите в сторону
`RecoveringParserRunner`, если вам нужно продолжать парсинг в случае ошибок.

[runners]: https://github.com/sirthias/parboiled/wiki/Parse-Error-Handling


# Тестирование

Разработчики Parboiled используют для тестирования фреймворк [specs2][specs2], который они дополнили своим
вспомогательным классом [TestParserSpec][tps]. Он покажется неудобным тем, кто использует scalatest, но основную
его идею можно и перенять. По секрету от Матиаса, его решение не отличается особенной аккуратностью, так как
полагается на изменяемое соатояние. Возможно, в будущем нас будет ждать что-то похожее на полноценный каркас
для тестирования.

[specs2]: https://etorreborre.github.io/specs2/
[tps]:    ???

Правила можно тестировать как по отдельности, так и вместе. Лично я предпочитаю писать тесты не на каждое правило,
а проверять только главное правило в заковыристых случаях.

> **Кулстори:** Во многих форматах данные, даже стандартизованных, могут встречаться весьма интересные моменты.
> Например, в BSD-подобном формате сообщений [RFC 3164][rfc3164] под число месяца *всегда* отводится две позиции,
> даже если само число имеет один разряд. Вот пример из самого RFC:
>
> > If the day of the month is less than 10, then it MUST be represented as a space and then the number. For
> > example, the 7th day of August would be represented as `"Aug  7"`, with two spaces between the `"g"` and
> > the `"7"`.

[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt

Помимо подобного рода «интересных моментов» можно скармливать правилу строки с незакрытыми скобками, недопустимыми
символами, проверять порядок операций со стеком значений.

В тестировании есть ещё одна тонкость, с которой вы сразу же столкнётесь. Предположим, вы хотите оттестировать
следуеющее правило:

    def Decimal = rule { ('+' | '-').? ~ Digit.+ ~ "." ~ Digit.+ }

Для этого скормим правилу заведомо некорректный ввод и будем ждать на выходе ошибку парсинга:

    // Я ещё не видел десятичных дробей с двумя разделителями.
    val p = new MyParser("12.3.456").Decimal.run()
    p.isFailure shouldBe true

Но при прогоне теста окажется, что парсер вернул удачный результат. Почему так? В нашем правиле нет `EOI`, но если если
мы добавим в него `EOI`, то испортим все правила, которые используют `Decimal`. Поэтому придётся создать специальное
тестирующее правило при помощи хитрого механизма [мета-правил][metaru]:

    def TestingDecimal = rule { Decimal ~ EOI }
    new MyTest("1.23.456").TestingDecimal.run().isFailure should be true

[metaru]: https://github.com/sirthias/parboiled2/blob/master/README.rst#advanced-techniques


# Недостатки Parboiled2

У любой, даже самой замечательной, библиотеки есть свои недостатки, и тут Parboiled2 не является исключением.

 - Длинные, слишком общие и совершенно непонятные сообщения компилятора об ошибках, в лучших традициях C++. Наглядный
   пример приведен на рисунке ниже (в правиле нечаянно пропущен оператор `~`). Причина связана с выполнением
   продвинутых проверок на типах, которые [обещают убрать][issue-106] в будущих версиях.

![Потеряшки ~](fig-lost-tilda.png)

[issue-106]: https://github.com/sirthias/parboiled2/issues/106

 - Эта проблема относится больше не к Parboiled2, а к scalac. Компилятору сносит крышу, если у лямбды,
   захватывающей значения со стека, явно определены типы аргументов:

        // scalac: «Okay»
        def MyRule = rule { oneOrMore(Visible) ~> (s => "[" + s + "]") }

        // scalac: «No way!»
        def MyRule = rule { oneOrMore(Visible) ~> (s: String => "[" + s + "]") }

 - Многие IDE ещё не научились поддерживать макровыражения, а Parboiled2 весь построен на макровыражениях. Поэтому
   верить подчеркиваниям вашей среды разработки не стоит. Однажды я, забыв об этом, потратил целый день на поиск
   несуществующей ошибки буквально на ровном месте.

 - Отсутствие механизма восстанолвения при неудачном разборе. Проектирущих предметно-ориентированные языки, или же
   тех, кто хочет использовать Parboiled2 в качество фронтэнда к своему компилятору, это сильно разочарует. Но над этим
   уже [работают][issue-42].

[issue-42]: https://github.com/sirthias/parboiled2/issues/42

 - Я думаю, что многим разработчикам своих небольших IDE, текстовых редакторов хотелось бы видеть более гибкие сообщения
   об ошибках, чем те, что предоставляются сейчас. На данный [момент][issue-96] существует всего два способа повлиять
   на них:
    - именованные правила,
    - именованные вложенные правила.

[issue-96]: https://github.com/sirthias/parboiled2/issues/96

 - Parboiled не приспособлен к лево-рекурсивным грамматикам, поэтому вам придётся доработать вашу грамматику под
   Parboiled.


## Миграция

Миграция — процесс, чаще всего, несложный, но занимает порядочно времени. Поэтмому я постараюсь хотя бы немного
сэкономить вам время и описать основные подводные камни.


### Classpath

Для того чтобы избежать конфликтов с первой версией, Parboiled2 использует classpath `org.parboiled2` (тогда
как classpath для первой версии `org.parboiled`). Мавеновский `groupId`, однако, остался старым: `org.parboiled`.
Благодаря этому можно иметь обе зависимости в одном проекте и осуществлять постепенный переход на новую версию.


### Проверка тестов

Убедитесь в наличии и работоспособности тестов. Они же у вас есть? Нет? Напишите их. В процессе миграции мне
приходилось уточнять некоторые грамматики из-за того, что новый DSL стал мощнее, и тесты при этом часто падали.
С серьезными проблемами, вроде поломки всей грамматики целиком, при миграции я не сталкивался. Может быть кто-то
поделится опытом, если с ним это произошло.


### Код вокруг парсера

Теперь, парсер будет пересоздаваться каждый раз, что не всегда удобно. С PB1 я очень любил создавать парсер один раз,
а потом многократно его переиспользовать, теперь же этот номер не пройдёт, поэтому вам придётся изменить конструктор
парсера и немного переписать использующий его код, и не бойтесь, что это ухудшит производительность.

Однако если вы использовали парсеры на сайдэффектах или генерировали их в рантайме динамически, вам, вероятно,
придётся помучиться: макровыражения в Parboiled2 больно бьют по динамике, давая взамен лучшую производительность.


### Композиция

Подход к композиции элементов парсера не изменился, это хорошая новость для миграторов. Однако `Parser` теперь не
трейт, а абстрактный класс. Трейты (traits) — удобнейшее средство композиции програмных компонентов, в PB1 это позволяло
подмешивать `Parser` в любые модули, смешивая модули между собой. Изменение в пользу абстрактного класса на эту
возможность никак принципиально не повлияло, но теперь для этого нужно использовать self-typed reference:

    trait Numbers { this: Parser =>
      // your code
    }

Также потребуется устранить лишние подмешивания парсера в подмодулях.

Как альтернативный вариант, вы можете сделать из ваших трейтов полноправные парсеры и импортировать из них нужные
правила (как методы) в ваш основной парсер. Я, правда, всё равно предпочитаю использовать для композиции трейты,
потому как нахожу их более наглядными.


### Ревизия велосипедов

В процессе миграции обязательно устройте ревизию своей личной библиотечки примитивных правил: после появления
таких стандартных классов, как `CharPredicate`, она должна заметно похудеть. Нет ничего приятнее, чем выкидывать
ставший ненужным код из проекта.

# Goodies

Некоторые интересные вещи, которые поддерживаются Parboiled2
 - Разбор строк закодированных в Base64
 - Встраиваемый в парсер StringBuilder, с хэлперами для доступа
 - Возможность динамической диспетчеризации правил (DynamicRuleDispatch)
Есть еще один полезный класс, не затронутый в документации: [CharUtils](http://bit.ly/1NJJ2kd). Его использование,
возможно, упасет вас от написания собственного велосипеда.


## Мне достался первый Parboiled

Большинство проектов всё ещё написаны на Parboiled1, и вряд-ли что-то изменится резко и кардинально (в энтерпрайзе),
поэтому может быть полезным знать, как научиться мириться с его недостатками.


### Ограничение на 7 правил

Parboiled1 построен так, что на каждое правило с N элементами имеется по классу, по аналогии со скаловскими кортежами
(tuples): есть `Rule0`, `Rule1`, вплоть до `Rule7`. Этого вполне достаточно, чтобы распарсить сложные языки
программирования, такие как Java, да и вообще не вызывает существенных проблем при разборе древовидных структур.
А вот если нужно извлечь данные из линейной структуры, например, сообщения лога-файла, то в это ограничение очень
несложно упереться. Решается это использованием кортежа вместо одного результирующего правила. Вот пример:

    def Event: Rule1[LogEvent] = rule {
      Header ~ " " ~ UserData ~ " " ~ Message ~~> {
        (header, data, message) => SyslogEvent (
          header._1, header._2, header._3, header._4, header._5, data._1, data._2, message
        )
      }
    }

Пусть выглядит убого, зато проблема решена.


# Best practices

В этом разделе я раскажу о прописных истинах работающих для любого парсер комбинатора, а так же нюансах, специфичных для
Parboiled2.


## Пишите модульные тесты

Одно небольшое неудачное изменение может сломать вам грамматику и обеспечить острую ректальную боль. Это Банальный
совет, которым многие пренебрегают. Парсер не так сложно протестировать, как, скажем IO: Вам не нужны Mock-объекты и
другие ухищрения для этой рутинной, но очень ценной работы. У нас была целая инфраструктура парсеров. И поверьте, первое
что я делал при поиске ошибок - садился и писал тесты, в случае их отсутствия.


## Делайте парсеры маленькими (по возможности)

Разделяйте ваши парсеры, на подпарсеры. Каждый компонент должен делать что-то вполне определенное. Например если вы
парсите LogEvent, у которого опредено поле Timestamp (особенно если этот Timestamp соответствует какому-нибудь Rfc).
Не поленитесь и вынесите его отдельно.

  - Во-первых это уменьшит код вашего основного прасера, и сделает его нагляднее
  - Во-вторых это заметно облегчит тестирование. Вы покроете модульными тестами ваш сабпарсер. А после этого приступите
    к разработке главного парсера

Существуют разные подходы:

 - Разбивать парсер на трейты и использовать self-typed reference (предпочитаю этот способ).
 - Объявлять парсеры как самостоятельные сущности и использовать композицию.
 - Использовать встроенный механизм для создания subParsers

## Делайте правила маленькими

Правила должны быть максимально компактными, но не компактней. Чем меньше ваши правила, тем легче найти ошибку в
грамматике. Очень сложно понять логику разарботчика, если он делает правила длинными, и при этом, многократно
использует `capture`. Усугублять ситуацию может неявный захват.


## Отправляйте case objects вместо строк в Value stack

Данный совет можно отнести и к оптимизациям, Потому что заставляет парсер работать быстрее.
Отправляйте в Value stack значимые объекты, а не строки. Это сделает ваш парсер быстрее а код нагляднее.

Плохо:

    def logLevel = rule {
      capture("info" | "warning" | "error") ~ ':’
    }

Хорошо:

    def logLevel = rule {
        “info:”   ~ push(LogLevel.Info)
      | “warning" ~ push(LogLevel.Warning)
      | “error"   ~ push(LogLevel.Error)
    }


## Используйте упрощенный синтаксис для сборки объекта

Этот красивый способ появился еще в Parboiled1. Никакой магии, просот конструктор case classа вызывается неявно.
Главное, чтобы количество и тип аргументов помещаемых на Value Stack совпадали с сигнаторой конструктора case classа.

Плохо:

    def charsAST: Rule1[AST] = rule { capture(Characters) ~> ((s: String) => AText(s)) }

Хорошо:

    def charsAST = rule { capture(Characters) ~> AText }


## Именнованные правила (named rules)

Именованные правила заметно упрощают жизнь при получении отчетов об ошибках, так как дают возможность вместо
бестолкового имени правила использовать псевдоним. Или же помечать правила определенным тегом - "Йоу! Это выражение"
или "аффектит стек". В люобм случае знать о данной функции будет полезно.

Многие пользователи Parboiled1 уже полюбили эту фичу. Например разработчики Neo4J, использующие Parboiled для
разбора языка [Cypher](http://neo4j.com/docs/2.2.3/cypher-introduction.html).
Как это выглядит в Parboiled1:

    def Header: Rule1[Header] = rule("I am header") { ... }

В Parboiled2:

    def Header: Rule1[Header] = namedRule("header is here") { ... }

Так же есть возможность давать имена вложенным правилам:

    def UserName = rule { Prefix ~ oneOrMore(NameChar).named("username") ~ PostFix }


# Микроптимизации

Главное при выполнении оптимизаций — своевременность. Это то, с чем не принято спешить. Но если есть возможность сразу
написать чуть более оптимальный код, не особенно потеряв в выразительности — этой возможностью следует воспользоваться. 


## Разворачивайте `n.times` для малых *n* ⩽ 4

Вы можете выиграть в производительности, если для малых *n* вместо оператора повторения `n.times` просто соедините
в цепочку несколько повторяющихся правил. Сколько повторений имеет смысл разворачивать — зависит от обстоятельств, но
едва ли это число больше четырёх.

    // Не айс.
    rule { 4 times CharPredicate.Digit }

    // Айс.
    import CharPredicate.Digit
    rule { Digit ~ Digit ~ Digit ~ Digit }

Актуальность этой оптимизации [провозглашена][issue-101] самим Маттиасом, хотя, гипотетически, оператор `n.times` мог
бы и сам её выполнять.

[issue-101]: https://github.com/sirthias/parboiled2/issues/101

Кроме того, использование подобной техники позволит вам выжать немножко производительности и при из извлечении данных
со стека значений. Например, так можно применить её к предыдущему правилу:

    def Digit4 = rule {
      Digit ~ Digit ~ Digit ~ Digit ~
	    push(#(charAt(-4))*1000 +
	         #(charAt(-3))*100  +
		     #(charAt(-2))*10   +
		     #(lastChar))
    }


### Не пересоздавайте `CharPredicate` каждый раз

Совершенно нормально радоваться новым возможностям класса `CharPredicate`, однако создавать свои экземпляры типа
`CharPredicate` внутри блока `rule` совершенно не стоит: ваш предикат будет пересоздаваться каждый раз, когда
выполняется правило, что трагически испортит производительность вашего парсера. Поэтому не создавайте их каждый раз,
а определите единожды внутри вашего парсера как константу:
    class UselessParser(val input: ParserInput) extends Parser {
      val Uppercase = CharPredicate.from(_.isUpper)
      ...
    }

или, что ещё лучше, отправьте это объявление в объект-компаньон вашего парсера:

    class UselessParser(val input: ParserInput) extends Parser {
      ...
    }

    object UselessParser {
      val Uppercase = CharPredicate.from(_.isUpper)
	}


### Используйте семантические предикаты

Особенность данных правил в том что они не взаимодействую со стеком значений. Они подробно описаны в документации, но
вот самое главное, что вы должны о них знать:

> При использовании сематрических предикатов парсер не совершает прогресса, то есть не перемещает свой курсор на
> следующий символ. Поэтому при их бездумном использовании парсер может зациклиться.

Помните пример c объявлением символьного предиката для символов верхнего регистра? Вы можете сделать тоже
самое, используя семантический предикат `test`:

    def JavaUpperCase = rule { oneOrMore(test(currentChar.isUpper) ~ ANY) }


### Используйте `ANY` там, где хотели бы видеть `CharPredicate.All`

Увы, `CharPredicate.All` работает медленно для больших диапазонов символов, `ANY` работает быстрее. Воспользуйтесь
этим знанием.


### Используйте инвертирующий предикат

Представьте, что ваш парсер должен захватывать все символы до перевода строки (для определённости, в стиле Unix).
Конечно, это можно сделать при помощи `noneOf`, но инвертирующий предикат будет быстрее:

    // Не айс.
    def foo = rule { capture(zeroOrMore(noneOf("\n"))) }

    // Айс?
    def foo = rule { capture(zeroOrMore(!'\n')) }

К сожалению, этот замечательно выглядящий пример зациклит, потому что парсер не будет совершать прогресса. Чтобы это
исправить, необходимо правило, передвигающее курсор парсера, но при этом не изменяющее стек. Например, вот такое:

    // Айс!
    def foo = rule { capture(zeroOrMore( !'\n' ~ ANY )) }

Теперь правило `foo` поглотит абсолютно все, кроме `EOI` и перевода строки.


# Заключение

Спасибо что дочитали этот длиннопост до конца, или хотя бы пролистали. В этой статье я попытался рассказать вам про
самый прогрессивный и перспективный инструмент парсинга существующий для языка scala. Сделал небольшой туториал, и
рассказал о тех проблемах с какими пришлось столкнуться на практике. Надеюсь что что эта статья в худшем случае окажется
для вас полезной, а в лучшем - станет руководстком к действию.

# Использованные источники

 - [Список рассылки проекта Parboiled][mail-list]
 - [Презентация Александра Мыльцева][myltsev-presentation] и [слайды к ней][myltsev-slides]
 - [Примеры кода из репозитория Parboiled][pb-examples]
 - [Парсер языка scala, написаный при помощи Parboiled2][scala-parser]

[mail-list]:            https://groups.google.com/forum/#!topic/parboiled-user/Ygb_M6XU5P8
[myltsev-presentation]: http://www.youtube.com/watch?v=qZg4D62K4aQ
[myltsev-slides]:       http://myltsev.name/ScalaDays2014/#/
[pb-examples]:          http://bit.ly/1H2ZQ3A
[scala-parser]:         https://github.com/sirthias/parboiled2/tree/master/scalaParser/src

# Благодарности
