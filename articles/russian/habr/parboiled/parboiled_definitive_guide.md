# Все, что вы хотели знать о Parboiled

Сегодня, в свете бурного роста популярности функциональных языков, всё чаще находят применение комбинаторы парсеров —
подход, облегчающий разбор текста простым смертным. Такие инструменты, как Parsec (Haskell) и Planck (OCaml) уже успели
хорошо себя зарекомендовать в своих экосистемах. Их удобство и востребованность в своё время подтолкнули создателя
языка Scala, Мартина Одерски, внести в стандартную библиотеку их аналог — Scala Parser Combinators
(ныне вынесены в scala-modules), а знание и умение пользоваться подобными инструментами — отнести к обязательным
требованиям к Scala-разработчикам [уровня A3](http://www.scala-lang.org/old/node/8610).

Эта статья посвящена библиотеке Parboiled — мощной альтернативе и возможной замене для Scala Parser Combinators.
Мы подробно рассмотрим работу с текущей версией библиотеки — Parboiled2, а также уделим внимание Parboiled1,
так как большая часть существующего кода всё ещё использует именно её. Мы затронем следующие вопросы:

 - Почему Parboiled?
 - Введение в Parboiled2 от простого к сложному.
 - Миграция с первой на вторую версию библиотеки.
 - Подводные камни Parboiled1 и Parboiled2.
 - Паттерны и best-practices™ при написании парсеров.

Итак, всех заинтересовавшихся прошу под кат.

------------------------------------------------------------------------------------------------------------------------

# Введение
Parboiled - библиотека позволяющая вам с легкостью разбирать (парсить) языки разметки (такие как HTML, XML или JSON),
конфигурационные файлы, логи, языки программирования, текстовые протоколы и многое другое. Если вы хотите спроектировать
свой предметно-ориентированный язык ([DSL](https://en.wikipedia.org/wiki/Domain-specific_language)) Parboiled придет вам
на помощь. Вы сможете получить древовидное представление вашей предметной области, или используя паттерн
[интерпретатор](https://en.wikipedia.org/wiki/Interpreter_pattern), исполнять команды вашего доменного языка.

На данный момент существует несколько версий данной библиотеки:

  - Parboiled for java - до сих пор пользуются популярностью, хоть и находится в состоянии End of Life. Если по воле
    случая она вам досталась в наследство, или же вы начинаете проект на java, предлагаю обратить ваше внимание на
    [grappa](https://github.com/fge/grappa). Эта библиотека является форком parboiled1, написана на java, и старательно
    поддерживается пользователем с ником fge.
  - Parboiled for scala появилась на свет после того как Mathias Doenitz (разработчик библиотеки) проникся скалой, он
    сделал scala-фронтэнд для parboiled, тем самым забросив поддержку java-версии. Потихонечку перестает поддерживаться,
    однако, не смотря на это списывать его со счетов ее тоже не стоит:
      - Parboiled2 не научился поддерживать все фичи Parboiled1
      - На данный момент Parboiled1 используется в большинстве проектов, с которыми возможно вам предстоит столкнуться
  - Parboiled2 - новейшая версия библиотеки, устраняющая ряд недостатков pb1. Работает быстрее и, самое главное:
    поддерживается разработчиками.

Как уже было написано ранее, данна статья написана с упором на Parboiled2. Иногда я буду отвлекаться, чтобы рассказать
об отличиях важных между первой и второй версиями библиотеки.


## Основные фичи Parboiled2
  - Parboiled2 основан на [PEG](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
  - Parboiled геренирует однопроходные парсеры. Лексер не требуется
  - Используется типобезопасный DSL являющися подмножеством языка scala
  - Оптимизации выполняются на этапе компиляции


## Почему Parboiled
  - Вам не нужно писать парсер голыми руками.
  - Parboiled основан на PEG. Это позволяет разбирть рекурсивные структуры данных (регулярные выражения не могут это
    [по определению](https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy)). Да, регулярными выражениями вы не
    распарсите JSON или даже простенький калькулятор (чего уж говорить о языках программирования). Небезызвестная
    цитата это подтверждающая:
> Parse arbitrary HTML is like asking Paris Hilton to write an operating system. (c)

  - Читаемость сравнимая с различными сортами BNF (по моему мнению даже и лучше)
  - Даже если вам нужно разобрать линейную (нерекурсивную структуру) parboiled2 (при использовании должных оптимизаций)
    будет работать быстрее регулярных выражений. Подтверждающие это данные получены
    [отсюда](https://groups.google.com/forum/#!msg/parboiled-user/XATcJRLTXjA/XSmf3n6gZSwJ).

        Бенчмарк:
          parboiled2 (warmup): 1621.212ms
          parboiled2: 409.162ms
          parboiled2 with better types (warmup): 488.919ms
          parboiled2 with better types: 134.676ms
          regex (warmup): 621.95ms
          regex: 620.379ms

  - В отличии от генераторов парсеров, таких как ANTLR, вы освобождены от генерации java кода парсера, который надо в
    последствии скармливать компилятору. Весь код в parboiled пишется на scala, поэтому вы получаете подсветку
    синтаксиса и проверку типов из коробки, а так же отсутствие дополнительных операций над файлами грамматик. Так же
    парсер, сгенерированный ANTLR будет иметь две фазы синтаксического разбора. В сравнении с Parboiled, ANTLR мощнее,
    документированее и стабильнее.
  - Скаловские парсер-комбинаторы работают медленно. Очень медленно. Слишком медленно. Mathias Doenitz проводил
    сравнение производительности Jackson и JSON парсеров сгенерированных с помощью библиотек Parboiled, Parboiled2 и
    Scala parser-combinators. С неутешительными результатами для последнего можно ознакомиться
    [здесь](https://groups.google.com/forum/#!topic/parboiled-user/bGtdGvllGgU).
  - В отличии от Language Workbenches, Parboiled - маленькая и простая в использовании библиотека. Вам не нужно
    скачивать плоходокументированного и тормозящего монстра, тратить часы драгоценной жизни на изматывающее общение с
    UI: поиск нужных менющек и кнопочек, всего-навсего для построения небольшого DSL. Да, вы не получите готовый
    текстовый редактор из коробки и, возможно, вам придется самостоятельно писать плагины для текстовых редакторов.
    Однако parboiled вполне достойная альтернатива для маленьких предметно-ориентированных языков.
  - parboiled успешно зарекомендовал себя во
    [многих проектах](https://github.com/sirthias/parboiled/wiki/Projects-using-parboiled).


### Parboiled2 против писанных-прямыми-руками Json парсеров
Небольшой benchmark, проведенный Александром Мыльцевым (разработчиком библиотеки Parboiled2) (взято
[отсюда](http://myltsev.name/ScalaDays2014/#/)), показывает, что скорость разбора приближается к "древним магическим
парсерам эльфийской работы"

                  бенчмарк    mc линейное время выполнения
      Parboiled1JsonParser 85.64 ==============================
      Parboiled2JsonParser 13.17 ====
                  Argonaut  7.01 ==
              Json4SNative  8.06 ==
             Json4SJackson  4.09 =


## Новые возможности Parboiled2
Данный раздел будет в основном полезен тем кто уже работал с первой версией библиотеки.

  - Parboiled2 решает ряд детских болезней первой версии
    - Решена так называемая Rule7-problem. Для этого была использована библиотека shapeless с ее знаменитыми HListами:
      теперь одно правило может оперировать большим количеством значений на стеке.
    - Добавлены недостающие конструкции. Например, В Pb1 нельзя было указать динамическое количество повторений для
      правила nTimes. Для решение приходилось использовать правило более "мягкое" правило oneOrMore, что не давало
      требуемой точности при описании грамматики.
    - Встроенные примитивные терминалы. Появился класс CharPredicate, который содержит такие поля как AlphaNumeric, Hex,
      Printable, Visible и другие. Многие пользователи pb1 писали свои маленькие стандартные библиотеки терминалов.
    - Добавлена возможность расширения и сужения предиката. Раньше возникала потребность исключить несколько символов из
      правила. Например нам нужны все видимые символы, кроме '=' и ']'. Теперь это с легкостью можно сделать. А не
      создавать "белый список" символов.
  - Parboiled2 использует дополнительную зависимость - библиотеку shapeless.
  - Parboiled2 использует макросы, это позволяет генерировать грамматику на этапе компиляции, а не во время выполнения,
    как это сделано для Parboiled1. Это многократно увеличивает производительность вашего парсера, и увеличивает
    количество проверок. В связи с этим блок 'rule' стал обязательным. В некоторых случаях (для Parboiled1) код
    корректно работает без него. Теперь это не так, учтите это когда будете делать миграцию.
  - Улучшена система отчета об ошибках
  - Поддержка scala.js. Демо-проект располагается
    [здесь](https://github.com/alexander-myltsev/parboiled2-scalajs-samples).


# Как работать с библиотекой
В этом разделе вашему вниманию будет представлен небольшой туториал о том, как работать с Parboiled2. В начале будет
рассказано об основных правилах сопоставления символов (Basic character matching). Все правила в рамках статьи мы
рассматривать не будем, для этого есть документация. После того как вы будете чувстсовать себя уверенно с DSL,
мы напишем простой распознаватель для несложной грамматики. Распознаватель (Recognizer) будет сопоставлять входной текст
с описанными нами правилами (продукциями) и не будет извлекать данные из сопоставленного текста какие-либо значения.
Затем вы узнаете как извлекать значения, и причем тут "Стек значений". Ну что, поехали?

## Подготовительные работы
Перед началом работы с библиотекой добавим ее в classpath, например в maven это делается так:

    <dependency>
        <groupId>org.parboiled</groupId>
        <artifactId>parboiled_2.11</artifactId>
        <version>2.1.0</version>
    </dependency>

Я использую scala 2.11, однако существует версия и для 2.10.
А теперь напишем парсер который ничего не делает, что не мешает ему существовать и радовать нас.

    import org.parboiled2._

    class MyParser(val input: ParserInput) extends Parser {
      // I am useless
    }

Конструкции DSL, а так же ряд полезных класов добавляются в зону видимости всего одной строчкой импорта.
Прошу заметить, что наличие поля input в конструкторе является обязательным, Input должен быть уникальным для каждого
экземпляра парсера. Это означает, что на каждый вход нужен новый парсер. Вначале, меня это очень сильно пугало, бояться
я перестал когда увидел как быстро оно работает.

Итак, никчемный парсер у нас уже имеется, теперь давайте опишем то, что нашему парсеру предстоит распознать. Напишем
небольшой распознаватель (recognizer), способный проверять правильность ввода. Если вход оказался валидным (с точки
зрения нашего парсера), нам просигнализируют об успешном выполнении операции, в противном случае скажут "что не так".

## Описываем правила (Rule DSL)
Работавшим с Parboiled1 этот раздел можно просто пролистать, (объяснения могут показаться им уж слишком подробными).
Тем кто знакомится с Parboiled2 впервые - можно и прочитать.
И начнем мы с терминалов. Это термин будет использоваться в дальнейшем, поэтому определим его так:
> Терминалы - символы не требующие дополнительных определений.

Теперь давайте добавим в наш парсер два приведенных ниже правила: одно должно распознать символ, другое строку.

    // Сопоставит (match) символ 'a'
    def MyCharRule = rule { ch('a') }

    // Сопоставит строку "string"
    def MyStringRule = rule { str("string") }

Каждый раз обозначать свои намерения подобным образом весьма уморительно. Благодаря механизму неявного преобразования
(implicit conversions), следующие правила будут выглядеть так:

    def MyCharRule = rule { 'a' }
    def MyStringRule = rule { "string" }

Существует возможность сопоставлять строки вне зависимости от их регистра:

    // передаваемая в правило строка должна быть в нижем регистре
    def StringWithCaseIgnored = rule { ignoreCase("string") }

Подробнее о правилах (Rules) (или "продукциях, если вам так нравится больше) будет рассказано далее в этой статье.
На данный момент нам необходимо знать что Rule0 сопоставляет вход с правилом и говорит нам совпало или нет.
Все приведенные ниже правила имеют данный Rule0. Мы его не указывали потому что вывод типов пока справляется.

    def StringWithCaseIgnored: Rule0 = rule { ignoreCase("string") }

В Parboiled существуют особенные терминалы:
  - EOI (End of Input) - виртуальный символ, котоый вы обязательно захотите добавить в конце главного правила
  Определен EOI так:

        val EOI = '\uFFFF'
  - ANY - соптавляет все символы, кроме EOI

>Если вы не объявите EOI в конце главного правила, и при парсинге возникнет ошибка, вы об этой ошибке не узнаете, так
как парсер будет думать что есть еще входные данные. Поэтому вас всегда ждет Success при любых входных данных.

Так же в Parboiled2 можно объявлять диапазоны символов. Делается это так:

    // Сматчат по одному символу
    def Digit      = rule { '0' - '9' }
    def AlphaLower = rule { 'a' - 'z' }

А вот Parboiled1 заставляет делать это часто - практически каждый раз, когда вы пишете парсер. Поэтому я носил свою
библиотечку примитивов из проекта в проект (Уверен, что не я один так делал). Теперь моя библиотечка, подистощилась
благодаря появлению CharPredicate. Думаю, что из названий будет понятно каким категориям символов они соответствуют.
 - CharPredicate.All (работает почти так же как Any, но производительность хуже на больших диапазонах символов)
 - CharPredicate.Digit
 - CharPredicate.Digit19
 - CharPredicate.HexDigit

Для CharPredicate работают правила 'except' и 'union', которых не было в pb1, (и, лично я от этого страдал)
Приходилось замыкать правило "с другой стороны" указвая "черный" или "белый" список, в зависимости от ситуации.

    // Сопоставит любой печатный символ, если это не кавычка
    def AllButQuotes = rule {
      CharPredicate.Visible -- "\"" -- "'"
    }

    // Вполне себе сойдет для определения идентификатора:
    // Alphanumeric объединяется с нижним подчергиванием
    def ValidIdentifier = rule {
      CharPredicate.AlphaNum ++ "_"
    }

> Приведенный в примере код будет работать не эффективно (с точки зрения производительности). Эффективный метод описан
в разделе Best Practices

Полезно будет рассказать еще о двух правилах: anyOf и noneOf. Работают они очень похоже на except и union для
CharPredicate, однако на всем пространстве символов ANY. И главное - для этого пространства они работают быстрее.
Эти функции могут принимать на вход строку состоящую из перечислений символов. Например:

    // Сопоставит, если символ является цифрой или одной из операций
    def DigitOrOperation = rule { anyOf("1234567890+-=/*") }

    // сопоставит все кроме пробела и EOI
    def EverythingExceptTheWhiteSpace = rule { noneOf(" ") }

Итак, что выбрать anyOf/noneOf или CharPredicate?
Заранее предопределенный CharPredicate будет работать быстрее для 7ми битных символов ASCII. Заранее предопределенный
написано не просто так (см. раздел Best Practices, там рассказано почему). Однако для больших диапазонов CharPredicate
ведет себя откровенно плохо. anyOf/noneOf должны работать быстрее для симвоволов находящихся в бОльших диапазонах.
Конечно же никто не будет матчить единичные символы. Поэтому перейдем к более сложным правилам:

### N.times
Правило которое позволяет сопоставить вполне конкретное число символов, выглядит так:

    def 33Cows = rule { 33 times "Cow" }

Некоторые грамматики требуют жесткого диапазона числа символов символов, например
[от двух до пяти](http://www.chukfamily.ru/Kornei/Prosa/Ot2do5/Ot2do5.htm). Теперь так можно сделать:

    import CharPredicate.Digit
    def FromTwoToFive = rule { 2 to 5 times Digit }

Для Parboiled1 существует правило nTimes, которое сопоставлет жестко заданное число символов.

### Цепочки
#### Правило "Все или ничего" (zero or more)
Делает то же что
[звезда Клини](https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0_%D0%9A%D0%BB%D0%B8%D0%BD%D0%B8) для
регулярных грамматик.

    def WhiteSpace = rule { anyOf(" \n\t") }
    // пробелов может быть много, а может и не быть
    def OptionalWhiteSpaces = rule { zeroOrMore(WhiteSpace) }

#### Правило "Один и более" (one or more)
Тоже что ZeroOrMore, однако хотя бы один символ должен присутствовать (идентично плюсу Клини для регулярных грамматик).

    def UnsignedInteger = rule { oneOrMore(Digit) }

#### Разделители
Зачастую цепочки требуется разделять, и делается это легко и непринужденно:

    def SeparatedNumbers rule { oneOrMore(Number).separatedBy(",") }

### Операция последовательности (Sequence)
Последовательность правил, выглядит как тильда '~'. Опишем электронный адрес некоего пользователя, зарегистрированного
на example.com

    // Предположим, что имя пользователя может включать все печатные символы
    // кроме собаки
    def UserName = rule { oneOrMore(CharPredicate.Visible -- "@") }

    // Правило опрелеляющее Email пользователя example.com
    def ReallySimplifiedEmail = rule { UserName ~ "@" ~ "example.com" }

### "Необязательное" правило (Optional)
Если бы существовало правило zeroOrOne, то это бы и был optional. Либо есть одно вхождение, либо вхождений нет совсем.
Давайте разберем следующий пример:
У каждой строки текста есть вполне себе newline. В разных семейства операционных систем он кодируется по разному.
Например в Unix-подобных операционных системах нужен всего символ "\n", тогда как в Windows нужна последовательность из
двух симвловов: "\r" и "\n". Поэтому наше правило должно выглядеть так:

    // Сопоставился newline для Linux, OS X, Windows
    def NewLine = rule { optional('\r') ~ '\n' }

### Упорядоченный Выбор (Ordered Choice)
Аналог "Или" в языках программирования и '|' в регулярных выражениях. Итак, предположим, что нам нужно распознать
число у которого может быть знак, а может и не может. Знак бывает двух типов: + и -. разберемся сначала с ним:

    // Знак бывает как положительный так и отрицательный
    def Signum = rule { '+' | '-' }

    // Знака может и не быть
    def MayBeSign = rule { optional(Signum) }

    // Число со знаком
    def Integer = rule { MayBeSign ~ UnsignedInteger }

Порядок следования правил имеет значение. Это исключает возможность появление неоднозначности вашей грамматике. И да,
так работают все PEG парсер-генераторы. Например, у нас стоит задача сопоставления операций сравнения для числовых
величин. Имеем следующие операторы: <,==,>,<=,=>. Запишем правило в сематнике Parboiled2.

    def ComparisonOperators = rule { "<=" | "==" | ">=" | "<" | ">" }

Парсер сопоставит правила для `<=`, `==` и `=>`. А вот если на вход мы скормим ему на вход `<`, то то он просто свалится
так ничего и не сопоставив. Как бы мы не меняли порядок в данном случае, какие-нибудь операторы обязательно не
будут сопоставленны. Парсер просто не пойдет проверять дальше. Поэтому, чтобы "работало" пример должен быть записан так:

    def ComparisonOperators = rule { "==" | ("<" ~ optional("=")) | (">" ~ optional("=")) }

### Немного сахара
Для optional, oneOrMore и zeroOrMore существует "синтаксический сахар", позволяющий сделать определения еще короче.
Пожалуйста, используйте его мудро, ибо если навертеть, ваши правила будут читаться немногим лучше чем регулярки.

    import CharPredicate.Digit

    // + для oneOrMore
    def UnsignedInteger = rule { Digit.+ }

    // ? для optional
    def SignedInteger   = rule { (+ | -).? ~ UnsignedInteger }

    // и * для zeroOrMore
    def Integers  = rule { SignedInteger * "\n") }
    // Делает то же самое, но при этом лучше читается
    def BetterIntegers = rule { zeroOrMore(SignedIntegers) separatedBy "\n" }

### Первый прогон
Прогонять следует главное (коррневое) правило (если вы конечно не пишете модульные тесты). Давайте осуществим наш первый
прогон на простом правиле MyStringRule, которое было описано выше.
Для того, чтобы совершить прогон у каждого правила определен метод `run()` (скобочки обязательны). Добавляем правило к
нашему бесполезному парсеру (не забудьте добавить EOI):

    import org.parboiled2._

    class MyParser(val input: ParserInput) extends Parser {
      def MyStringRule: Rule0 = rule {
        ignoreCase("string") ~ EOI
      }
    }

И теперь, где-нибудь в другом месте создайте экземплляры парсеров, и подайте им на вход разные данные:

    val p1 = new MyParser("STRING")
    val p2 = new MyParser("won't match")

    // по-умолчанию возвращают scala.util.Try
    p1.MyStringRule.run()
    p2.MyStringRule.run()
    
>Прогон правил в Parboiled2 выполняется намного проще чем в первом Parboiled, для которого существует целый зоопарк
Parser Runnerов, которые приходится дополнительно вызывать. За более подробной информацией, прошу в раздел
"Отчеты об ошибках".

### Вложенные структуры данных
То что может Parboiled и не могут регулярные выражения - разбор рекусивных структур. В Parboiled - это делается легко
и непринужденно, что и будет продемонстрированно на последующих примерах. Единственное дополнительное усилие которое от
вас требуется - явно объявить тип в в том месте где используется рекурсивыный вызов.

Чтобы продемонстрировать разбор рекурсивных структур данных, зачастую, в качестве примера демонстрируют простой
калькулятор. По моему мнению - калькулятор не нагляден. В качестве примера у нас будет простенький формат
конфигурационных файлов, состоящий на основе именованных блоков и пар "ключ-значение".

#### Формат BKV - Blocked Key-Value
В качестве примера мною будет использоваться формат BKV, который был придуман специально для данной демонстрации.
Возможно подобный формат существует и даже имеет имя. Пожалуйста дайте мне знать, если это так :).
Итак формат BKV состоит из блоков, и пар ключ-значение. Выглядит примерно так:

    server {
      port = "8080"
      address = "localhost"

      settings {
        greeting_message =-"Hello!\n It's me!"
      }
    }

Как видите, формат прост и незатейлив. Строки с экранированием (escaping) могут напугать не писавших парсеры ранее.
Данный паттерн очень часто встречается при синтаксическом разборе, поэтому мы обязательно, в подробностях его
рассмотрим.

Начем описание со вспомогательных элементов, а именно с пробелов.
В нашем случае пробелом будут являться следующие символы: ' ', '\n' и '\t'. Конечно, существует большее число
пробельных символов, но в примере мы ограничимся тремя. Существуют разные способы сделать это:
 - объявить символы через оператор "упорядоченного выбора"
 - Объявить свой CharPredicate, и задать эти три символы.
 - использовать anyOf
Мы воспользуемся последним (найти его определение можно выше). Так же мы объявим правила для необязательных пробелов
(описано выше) и для обязательных (сделано по аналогии с OptionalWhitespaces).

TODO: нужны ли RequiredWhitespaces?

В некоторых местах пробелов может быть несколько, в некоторых может не быть, а кое где пробелы должны быть
обязательными

В нашем случае Ключ представляет собой валидныq bltynbabrfnjh для большинства языков
программирования. Наш Ключ может содержать цифры, буквы английского алфавита (строчные и заглавные), а так же символ
подчеркивания `_`.

    import CharPredicate.AlphaNum
    def Key = rule { oneOrMore(AlphaNum ++ "_") }

TODO:

    // Любой символ, кроме пробела и перевода строки
    def Value = rule { oneOrMore(noneOf(" \n")) }
    def KeyValuePair = rule { Key ~ zeroOrMore(Spaces) ~ "=" ~ zeroOrMore(Spaces) ~ NewLine }

На данном этапе мы написали простой распознаватель, исходный код которого находится [тут](TODO). Сопоставлять значения
на практике приходится весьма редко. А вот захватывать их "каждый раз". Итак перейдем к "захватывающим историям"

## Стек значений (Value Stack)
Прежде чем извлекать какие-либо данные при помощи правил, следует немного рассказать про одно из средств парсера в
Parboiled. И средство это называется Value Stack или Стек значений. Представляет он из себя простой стек, который
выступает временным хранилищем для действий (Parser Actions) над извлекаемыми при помощи правил объектами. Именно этому
самому стеку мы должны дать подсказку при объявлении рекурсивных правил. Для того чтобы элементы были помещены на Стек
значений, их необоходимо захватить, это отразится на типе ваших правил. Типы правил так же отражают количетсво
захваченных элементов и их тип. Типизация стека значений проверяется на этапе компиляции. 

## Типы правил
В Parboiled2 существуют следующие типы правил:

 - Rule0 - Отвечает на вопрос "Сопоставилось ли?". Не изменяет содержимое стека.
 - Rule1 - Помещает один объект в стек значений
 - Rule2 - Помещает два объекта в тот же самый стек
 - RuleN - Помещает N объектов В стек значений. Использует семантику Shapeless. Для работы с Parboiled2 Shapeless знать
   не нужно (хотя и будет полезно).
 - PopRule - извлекает значения со стека, при этом не помещая туда новых значений

При желании можно объявить свои псевдонимы для типов (как в Parboiled1). Например так реализуется Rule2:

    type Rule2[+A, +B] = RuleN[A :: B :: HNil]

В Parboiled1 для каждого количества аргументов (от 0 до 7) существовало по правилу. Проблема в том что Rule8 уже нет,
и положить восемь элементов в стек значений не представляется возможным. Существуют различные окольные пути для решения
этой проблемы, расскажу про один из них далее в статье.

## Действия парсера (Parser Actions)
Действия на парсерах позволяют извлекать данные из сопоставившихся правил, преобразовывать их в зависимости от степени
вашей испорченности, или же использовать эти данные ради какого-нибудь сайд-эффекта. Последнее является весьма полезной
техникой (в случае если размер и количество извлкаемых нами данных заранее не известны).
С помощью действий можно формировать абстрактные синтаксические деревья
([AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)).
Так же действия можно использовать для "вычислений на месте", как это сделано в примере с
[калькулятором](http://bit.ly/1iJg7zP).

### Захватывающие истории
Как было сказано выше, для того чтобы совершить какое-то дейстие над данными нам надо их захватить. Для этого существует
функция `capture`. Capture сравнивает данные с правилом, и в случае совпадения помещает данные на стек значений.
Предположим у нас есть некое правило Rule0 из которого мы хотим что-то вытащить:

    def User: Rule = rule { FirstName ~ Separator ~ LastName }
Теперь нам нужно решить, что мы будем захватывать. Очевидно что разделитель не представляет художественной ценности:

    def User: Rule2[String, String] = rule { capture(FirstName) ~ Separator ~ capture(LastName) }
И с этого момента наше правило уже не Rule0. Данные захваченны и оправленны в Стек значений. Впрочем, тип можно не
указывать, компилятор и так все поймет сам.

### "Оператор действия ~> ()"
... или оператор, которым вам придется пользоваться чаще всего. В качестве параметра принимает лямбду. Снимает значения
cо стека значений и позволяет вам проделать с этими операциями некие действия, а потом, возможно положить в стек. Это
уже зависит от вашего желания. Для того чтобы действие осуществилось, функция Capture должна является обязательной и про
нее не стоит забывать (Привет пользователям Parboiled1). В завимисости от типа возвращаемого значения способен принимать
различные формы. Это делает использование данного оператора интуитивным, и простым.

Теперь подробнее про лямбду. Вид ее будет зависеть от количества и типизации захваченных объектов. За раз лямбда не
может захватить более 9 аргументов (TODO: проверить). При наличии одного захваченного правила, лямбда будет принимать
одно значение типа String. Хранить на стеке строку мне не очень хочется, поэтому преобразуем ее в целое число.

    def Number: Rule1[Int] = rule { capture(Digit.+) ~> (numStr => numStr.toInt) }
В этой ситуации поощряется использование фирменного скаловского плейсходера:

    def Number: Rule1[Int] = rule { capture(Digit.+) ~> (_.toInt) }
Преобразования можно делать так (пример из документации):

    (foo: Rule1[Int]) ~> (i => i * 2)
После преобразования, резутльтирующее правило так и останется Rule1[Int]. А вот на стеке будет лежать другое значение.

> Объявлять тип аргументов лямбда функции не очень хорошая идея (на момент написания статьи). В компиляторе scala
существует весьма неприятный баг, не дающий вашему коду скомпилироваться.

С одним аргументом мы разобрались. А что делать если их несколько? Как поведет себя лямбда? Просто предсказуемо:
представьте что Стек значений растет справа налево. Соответственно самое левое из захваченных значений (первое на
стеке) или, если вам будет проще (Значение соответствующее типу самого левого типа в дженерике) будет первым аргументом
лямбды и так далее. Напрмиер для Rule2[Int, String], лямбда параметры лямбда выражения будут иметь следующий порядок:

    (i: Int, s: String) => // ваш код
Благодаря преобразованиям мы можем уменьшать количество значений на стеке:

    (foo: Rule2[Int, String]) ~> ((i, s) => s"$i раз по $s")
Результирующим правилом будет Rule1[String].

Лямбда-выражение не обязанно принимать ВСЕ параметры со стека. Можно вполне ограничиться последними N параметрами
(лямбда забирает аргументы с конца):

    (foo: Rule2[Int, String]) ~> (_.toDouble)
Результирующим правилом будет Rule2[Int, Double]. Так как лямбда захватывает последние значения со стека (если их
передать), мы можем попробовать скормить ей функцию не имеющую аргументов:

    (foo: Rule1[String]) ~> (() => 42)
Результрующим правилом у нас будет.... Rule1[String, Int]

У Parboiled2 есть более мощные инструменты. Например, есть возможность вернуть группу значений:

    (foo: Rule1[Event]) ~> (e => e::DateTime.now()::"localhost"::HNil)

Фактически мы конструируем фирменный шейплесовский HList. Тип результирующего правила будет (TODO: Проверить)
RuleN[Event::DateTime::String::HNil].

Так же можно собирать из стека значения, ничего не давая взамен. Для этого, возвращаемым типом лямбда выражения должен
быть Unit. Результирующим правилом, как вы наверное догадались, будет Rule0.

    (foo: rule1[String]) ~> (println(_))

Самый сладкий сахар, что предлатает оператор действия, для case classов. 

    case class Person(name: String, age: Int)

    (foo: Rule2[String, Int]) ~> Person
    
Стоит отметить, что если для case class определен companion object, то сахарок может не сработать. Так что в качества
обходного решения придется воспользоваться лямбдой увиденной нами ранее, и записать: `~> (Person(_, _)`

Данный юзкейс идеально подходит для построения AST. Опытные пользователи Parboiled1 могут заметить что данный сценарий
использования оператора `~>` аботает аналогично оператору `~~>` в Parboiled1.
Существуют другие техники использования данного оператора, о них вы узнаете в документации.
Как бы сложно не выглядело описание данного оператора, им просто и интуитивно пользоваться. Пожалуй самое лучшее
техническое решение, принятое на этапе создания DSL.

### run
Наиболее универсальное действие парсера. Во многих случаях run ведет себя так же как оператор `~>`. Однако отличия тоже
присустсвуют
TODO:

#### Side-effect
TODO: Рассказать про правило ~% в parboiled и про то как выглядит его замена

### push
Функция push помещает указанные данные на стек значений, в случае если правило сопоставилось. На практике не приходилось
им пользоваться часто, да и большую часть работы может выполнить оператор `~>`, однако существует юзкейс, при котором
функция push будет блистать:

    sealed trait Bool
    case object True extends Bool
    case object False extends Bool
    
    def BoolMatch = rule { "true" ~ push(True) | "false" ~ push(False) }

>Хоть это нигде и не помеченно, данное правило ведет себя как call-by-name, и вычисляется каждый раз, это означает
что аргумент переданный данной функции вычисляется каждый раз. Согласитесь, не очень хорошо для производительности.
Поэтому push лучше использовать с константами и только константами.

Так же как и run, и `~>` определяет содержимое стека в зависимости от типа возвращаемого значения.

### Вложенные парсеры

## Генерация AST
TODO: from the pb1 documentation
Contrary to the parse tree, which is very closely tied to the grammar by its direct relation to the grammar rules,
the Abstract Syntax Tree you might want to construct for your language heavily depends on your exact project needs.
This is why parboiled takes a very open and flexible approach to supporting it.
There are absolutely no restrictions on the type of your AST nodes. parboiled does provide a number of immutable
and mutable base classes you might choose to use, however, there is nothing that forces you to do so. Take a look at
the org.parboiled.trees package to get started.

# Отчеты об ошибках 
TODO: from the pb1 documentation
The proper handling of illegal input (with regard to the language defined by your grammar) is a key feature of any
parser that is to be used in real-world projects, and it’s one of the big drawbacks of regular expressions. For example,
if you have a user provide input in a custom DSL you can be sure he or she will make syntactic and/or semantic mistakes
at some point. The latter ones will have to be caught and reported by higher levels of your application, however, the
syntactic ones can and should be caught, reported and dealt with directly in the parser.

## Восстановление после ошибок
Единственный эпизод где Parboiled1 выигрывает.
В Parboiled2 дела обстоят не очень хорошо. Парсер падает от вида первой, встреченной им ошибки. Для
большинства сценариев использования это отлично подходит. Это не мешает парсить логи и конфигурационные файлы (которые
должны приходить валидными по умолчанию), однако разработчикам DSL или IDE-подобных инструментов данное положение дел
будет не подуше. [Обещают исправить](https://github.com/sirthias/parboiled2/issues/42). Если вам эта фича очень нужна
напишите об этом на issue tracker - это ускорит процесс разработки.

Для Parboiled1 существует гибкий набор ParserRunnerов с которым можно ознакомиться
[здесь](https://github.com/sirthias/parboiled/wiki/Parse-Error-Handling). Смотрите в сторону RecoveringParserRunner. 


# Тестирование
TODO: from pb usergroup
Well, seeing that the `TestParserSpec` is a mere 25 lines I have not yet deemed it worthwhile to include it.
Also, it is specific to specs2 (others might prefer scalatest) and not necessary the cleanest solution
(due to it relying on mutability).
But I’ll think about cooking something up that can be included, thanks for the hint!
TODO:


# Недостатки Parboiled2
У любой, даже самой замечательной библиотеки есть свои недостатки, Parboiled2 не является исключением.

 - Длинные, слишком общие и совершенно непонятные сообщения от компилятора. Которые не помогают. Пример приведен на
   рисунке ниже (в правиле отсутствует оператор ~):

   ![Потеряшки ~](https://cloud.githubusercontent.com/assets/934140/5181763/7aa8a570-744e-11e4-9011-fea34b07cdc9.png)

   Это связано с выполнением продвинутых проверок "на типах". Данные проверки
   [обещают](https://github.com/sirthias/parboiled2/issues/106) устранить в следующих версиях.
 - Эта проблема относится больше не к parboiled2, а к scalac. Дело в том что ему сносит крышу, если внутри лямбды,
   захватывающей значения с Value Stack определить типы. Пример ниже не скомпилируется:

    def MyRule = rule { oneOrMore(Visible) ~> (s: String => "[" + s + "]") }
   а вот этот, скомпилируется:

    def MyRule = rule { oneOrMore(Visible) ~> (s: String => "[" + s + "]") }
   пожалуйста, имейте это в виду.
 - Многие IDE еще не научились поддерживтаь Parboiled2. Поэтому Верить подчеркиваниям вашей среды разработки не стоит.
   Сам, забыв об этом, потратил целый день на поиск ошибки в простом подпарсере.
 - Отсутствие механизма восстанолвения при не удачном разборе. Для проектирущих предметно-ориентированные языки, или же
   тех, кто хочет использовать Parboiled2 в качество фронт-энда к своему компилятору это сильно разочарует. Смею вас
   заверить, над этим [работают](https://github.com/sirthias/parboiled2/issues/42).
 - Я думаю, что многим разработчикам своих небольших IDE, текстовых редакторов хотелось бы видеть более гибкие сообщения
   об ошибках, чем те, что предоставляются сейчас. На данный [момент](https://github.com/sirthias/parboiled2/issues/96)
   существует всего два способа повлиять на сообщения об ошибках:
    - Именованное правило
    - Именованное вложенное правило
 - Существуют проблемы с разбором символов, не попадающих в UTF-16. Очень много недовольных китайцев ломится на
   issue tracker.
 - Parboiled не доработан для поддержки лево-рекурсивных грамматик


# Миграция
Данный раздел посвящен миграции. Процесс несложный, но время занимает. Поэтмоу я постарался хотя бы чуточку сэкономить
ваше время, и описал основные тезисы в разделе.

## Classpath
Для того чтобы избежать конфликтов с первой версией. Parboiled2 использует другой classpath `org.parboiled2`, тогда
как classpath для первой версии `org.parboiled`. Maven group-id однако остался `org.parboiled`.
Благодаря этому можно иметь обе зависимости в одном проекте, и осуществлять постепенный переход на новую версию.

## Проверка тестов
Убедитесь в наличии и прохождении тестов. Есть ли они у вас? нет? Напишите их. В процессе миграции мне приходилось
уточнять некоторые грамматики (В виду того что новый DSL стал мощнее). Некоторые тесты в связи с этим падали. 
С более серьезными проблемами (вроде поломки грамматики целиком) при миграции я не сталкиваться.
Может быть кто-то поделится опытом если это произошло.

## Код вокруг парсера
Теперь, парсер будет пересоздаваться каждый раз. Знаю, это не всегда это удобно. С Praboiled1 я очень любил создавать
парсер один раз, а потом многократно его переиспользовать. Парсеры могут быть основаны на сайдэффектах, могут
генерироваться динамически. Parboiled2 использует макровыражения, что очень больно бьет по динамике (давая взамен лучшую
производительность). Начните с редизайна парсера и кода вокруг, если парсер простой, измените ваш код так, чтобы парсер
мог спокойно и удобно пересоздаваться. Измените интерфейсы и конструктор вашего парсера.

## Композиция
Подход к композиции элементов парсера не изменился. Это хорошая новость.

>Parser теперь не trait, а абстрактный класс.

Traits - удобнейшее средство для композиции програмных компонентов. Так как в Parboiled1 Parser являлся трейтом, можно
было подмешивать Parser в любые модули, смешивая модули между собой. Вобщем-то изменение в пользу абстрактного класса
на это никак не повлияло. Всего-то нужно использовать self-typed-reference:

    trait Numbers { this: Parser =>
      // your code
    }

И устранить лишние подмешивания парсера в подмодулях. Вы так же можете сделать из ваших трейтов полноправные парсеры и
импортировать из них нужные правила (как методы) в ваш основной парсер. Я предпочитаю использовать для композиции
трейты, потому что нахожу их более наглядными.

## Изменения правил
После этого измените ваши правила. В том числе правила стандартной библиотечки, если таковая имеется. Очень повезет тем
у кого таковая библиотечка отсутствует.

Убедитесь все модульные тесты зеленые. Сделайте реформу вашей стандартной библиотеки, она должна слегка похудеть.


# Что Parboiled (PEG) не может/не умеет
Большинство статей про комбинаторы парсеров начинается с изматывающих объяснений того что такое PEG, с чем его есть и
почему его надо бояться. Для того чтобы парсить конфиги, знать и разбираться в этом не обязательно. Однако знать что
знать ограничения данного типа грамматик стоит. Итак, в виду того что Parboiled является PEG он не умеет:

 - Разбирать леворекурсивные грамматики. Методы нисходящего разбора (top-down parsers), к коим относятся PEG не в
   состоянии работать с леворекурсивными грамматиками. В любом случае леворекурсивную грамматику можно
   [адаптировать](http://bit.ly/1O8aMyR)
 - Разбирать грамматики на отступах (Indentation-based grammars), например Python или YAML. Не получается это сделать
   из-за того что сгенерированный парсер является однопроходным (лексер отсутствует). Разбор отступов же выполняется на
   этапе лексического анализа. Однако, для решения данной проблемы существует решение: установка витруальных символов
   (маркеров) до (INDENT) и после (DEDENT) выхода в отступ. Для Parboiled1 сущестует
   [стандарное решение](https://github.com/sirthias/parboiled/wiki/Indentation-Based-Grammars), для Parboiled2 подобную
   процедуру пока придется выполнять самостоятельно
 - Использовать потоковый ввод (Streaming input). PEG используют поиск с возвратом, он же
   [бэктрекинг](https://en.wikipedia.org/wiki/Backtracking). Потенциальное обходное решение буферизация потока,
   выделение чанка в буффер с последующим разбором. После того как чанк будет разобран можно передвигаться далее по
   потоку. Данное решение, возможно, и окажется кому-то полезным


# Мне достался первый Parboiled
Да, большинство проектов все еще написаны на Parboiled1, и вряд-ли что-то изменится резко и кардинально (в энтерпрайзе).
В этом разделе я расскажу об основных известных мне проблемах, связанных с Parboiled1.

## Ограничение на 7 правил.
Parboiled1 построен так, что на каждое правило с N элементами имеется по классу. Устроено это так же как скаловские
кортежи (tuples). Есть Rule0, Rule1 и так вплоть до Rule7. Этого вполне достаточно чтобы распарсить сложные языки
программирования такие как Java. Да и вообще, это не вызывает проблем при разборе древовидных структур. А вот если нужно
извлечь данные из линейной структуры, например Лог сообщения. В ограничение очень несложно упереться. Решается это
использованием кортежа, вместо одного результирующего правила. Вот пример:

    def Event: Rule1[LogEvent] = rule {
      Header ~ " " ~ UserData ~ " " ~ Message ~~> {
        (header, data, message) => SyslogEvent (
          header._1, header._2, header._3, header._4, header._5, data._1, data._2, message
        )
      }
    }
Да, выглядит убого, однако проблема решается.


# Best practices
В этом разделе я раскажу о прописных истинах работающих для любого парсер комбинатора, а так же нюансах, специфичных для
Parboiled2.

## Пишите модульные тесты
Одно небольшое неудачное изменение может сломать вам грамматику и обеспечить острую ректальную боль. Это Банальный
совет, которым многие пренебрегают. Парсер не так сложно протестировать, как, скажем IO: Вам не нужны Mock-объекты и
другие ухищрения для этой рутинной, но очень ценной работы. У нас была целая инфраструктура парсеров. И поверьте, первое
что я делал при поиске ошибок - садился и писал тесты, в случае их отсутствия.

## Делайте парсеры маленькими (по возможности)
Разделяйте ваши парсеры, на подпарсеры. Каждый компонент должен делать что-то вполне определенное. Например если вы
парсите LogEvent, у которого опредено поле Timestamp (особенно если этот Timestamp соответствует какому-нибудь Rfc).
Не поленитесь и вынесите его отдельно.

  - Во-первых это уменьшит код вашего основного прасера, и сделает его нагляднее
  - Во-вторых это заметно облегчит тестирование. Вы покроете модульными тестами ваш сабпарсер. А после этого приступите
    к разработке главного парсера

Существуют разные подходы:

 - Разбивать парсер на трейты и использовать self-typed reference (предпочитаю этот способ).
 - Объявлять парсеры как самостоятельные сущности и использовать композицию.
 - Использовать встроенный механизм для создания subParsers


## Делайте правила маленькими
Правила должны быть максимально компактными, но не компактней. Чем меньше ваши правила, тем легче найти ошибку в
грамматике. Это спасало.

## Отправляйте case objects вместо строк в Value stack
Данный совет можно отнести и к оптимизациям, Потому что заставляет парсер работать быстрее.
Отправляйте в Value stack значимые объекты, а не строки. Это сделает ваш парсер быстрее а код нагляднее.

Плохо:

    def logLevel = rule {
      capture("info" | "warning" | "error") ~ ':’
    }
Хорошо:

    def logLevel = rule {
        “info:” ~ push(LogLevel.Info)
      | “warning" ~ push(LogLevel.Warning)
      | “error" ~ push(LogLevel.Error)
    }

## Используйте упрощенный синтаксис для сборки объекта
Этот красивый способ появился еще в Parboiled1. Никакой магии, просот конструктор case classа вызывается неявно.
Главное, чтобы количество и тип аргументов помещаемых на Value Stack совпадали с сигнаторой конструктора case classа.

Плохо:

    def charsAST: Rule1[AST] = rule { capture(Characters) ~> ((s: String) => AText(s)) }

Хорошо:

    def charsAST = rule { capture(Characters) ~> AText }

## Именнованные правила (named rules)
Именованные правила заметно упрощают жизнь при получении отчетов об ошибках, так как дают возможность вместо
бестолкового имени правила использовать псевдоним. Или же помечать правила определенным тегом - "Йоу! Это выражение"
или "аффектит стек". В люобм случае знать о данной функции будет полезно.

Многие пользователи Parboiled1 уже полюбили эту фичу. Например разработчики Neo4J, использующие Parboiled для
разбора языка [Cypher](http://neo4j.com/docs/2.2.3/cypher-introduction.html).
Как это выглядит в Parboiled1:

    def Header: Rule1[Header] = rule("I am header") { ... }
В Parboiled2:

    def Header: Rule1[Header] = namedRule("header is here") { ... }
Так же есть возможность давать имена вложенным правилам:

    def UserName = rule { Prefix ~ oneOrMore(NameChar).named("username") ~ PostFix }


# Оптимизации
Главное при выполнении оптимизаций - своевременность. Это то с чем не стоит спешить.
## Развертка n.times для n <= 4
Вы можете выиграть в производительности если вместо правила "times" для маленьких n

    rule { 4 times CharPredicate.Digit }
будете использовать правило последовательности "sequence" (оно же тильда)

    import CharPredicate.Digit
    rule { Digit ~ Digit ~ Digit ~ Digit }
Это связано в существующей на момент публикации данной статьи
[проблемой](https://github.com/sirthias/parboiled2/issues/101).

## Ускорение операций со стеком для nTimes
Использование подобной оптимизации при извлечении чисел со стека тоже позволит вам выжать немножко производительности

    def digit4 = rule {
      Digit ~ Digit ~ Digit ~ Digit ~ push(#(charAt(-4))*1000 + #(charAt(-3))*100 + #(charAt(-2))*10 + #(lastChar))
    }

## Используйте ANY, там где хотите видеть CharPredicate.All
TODO:

## CharPredicate работает очень медленно для больших диапазонов
TODO:

## Не пересоздавайте CharPredicate каждый раз
TODO
I currently don’t have the capacity to dig into this deeper but here is a work-around:
Instead of recreating the `CharPredicate` for every rule application by using

   CharPredicate.from(_.isUpper)

directly in the rule you should move it into a `val` of your parser class or, even better, into the companion object.
Alternatively you can use the `test` semantic predicate:

   def JavaUpperCase = rule { oneOrMore(test(currentChar.isUpper) ~ ANY) }


## Используйте инвертирующий предикат
TODO:
Будтье осторожны. При их использовании парсер не прогрессирует (не перемещает курсор), это может вызвать "зацикливание"
вашего парсера.
will capture all input until it reaches a comma

    def foo = rule { capture(zeroOrMore( !',' ~ ANY )) }


# Заключение
Спасибо что дочитали этот длиннопост до конца, или хотя бы пролистали. В этой статье я попытался рассказать вам про
самый прогрессивный и перспективный инструмент парсинга существующий для языка scala. Сделал небольшой туториал, и
рассказал о тех проблемах с какими пришлось столкнуться на практике. Надеюсь что что эта статья в худшем случае окажется
для вас полезной, а в лучшем - станет руководстком к действию.


Использованные источники
========================
 - [Юзергруппа](https://groups.google.com/forum/#!topic/parboiled-user/Ygb_M6XU5P8) посвященная Parboiled2
   Здесь вы можете задать все интересующие вас вопросы. Вам помогут.
 - Презентация Александра Мыльцева [Видео](http://www.youtube.com/watch?v=qZg4D62K4aQ)
 - [Слайды](http://myltsev.name/ScalaDays2014/#/) к презентации Александра [ENG]
 - Официальная [документация](https://github.com/sirthias/parboiled2/blob/master/README.rst)
 - [Примеры](https://github.com/sirthias/parboiled2/tree/master/examples/src/main/scala/org/parboiled2/examples)
   исходного кода
