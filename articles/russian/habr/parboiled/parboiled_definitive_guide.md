# Все, что вы хотели знать о Parboiled

Сегодня, в свете бурного роста популярности функциональных языков, всё чаще находят применение комбинаторы парсеров — 
подход, облегчающий разбор текста простым смертным. Такие инструменты, как Parsec (Haskell) и Planck (OCaml) уже успели
хорошо себя зарекомендовать в своих экосистемах. Их удобство и востребованность в своё время подтолкнули создателя
языка Scala, Мартина Одерски, внести в стандартную библиотеку их аналог — Scala Parser Combinators
(ныне вынесены в scala-modules), а знание и умение пользоваться подобными инструментами — отнести к обязательным
требованиям к Scala-разработчикам [уровня A3](http://www.scala-lang.org/old/node/8610).

Эта статья посвящена библиотеке Parboiled — мощной альтернативе и возможной замене для Scala Parser Combinators.
Мы подробно рассмотрим работу с текущей версией библиотеки — Parboiled2, а также уделим внимание Parboiled1,
так как большая часть существующего кода всё ещё использует именно её. Мы затронем следующие вопросы:

 - Введение в Parboiled2 от простого к сложному.
 - Миграция с первой на вторую версию библиотеки.
 - Подводные камни Parboiled1 и Parboiled2.
 - Паттерны и best-practices™ при написании парсеров.

Итак, всех заинтересовавшихся прошу под кат.

------------------------------------------------------------------------------------------------------------------------

Parboiled - библиотека позволяющая вам с легкостью разбирать (парсить) языки разметки (такие как HTML, XML или JSON),
конфигурационные файлы, логи, языки программирования, текстовые протоколы и многое другое. Если вы хотите спроектировать
свой предметно-ориентированный язык ([DSL](https://en.wikipedia.org/wiki/Domain-specific_language)) Parboiled тоже
придет вам на помощь. Вы сможете получить древовидное представление вашей предметной области. Или используя
паттерн [интерпритатор](https://en.wikipedia.org/wiki/Interpreter_pattern), исполнять команды вашего доменного языка.


## Основные фичи Parboiled2
  - Parboiled2 основан на [PEG](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
  - Parboiled геренирует однопроходные парсеры. Лексер не требуется.
  - Используется DSL являющися подмножеством языка scala.
  - Оптимизации выполняются на этапе компиляции


## Почему Parboiled
  - Вам не нужно писать парсер голыми руками.
  - Parboiled основан на PEG. Это позволяет разбирть рекурсивные структуры данных (регулярные выражения не могут это 
    [по определению](https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy)). Да, регулярными выражениями вы не
    распарсите JSON или даже простенький калькулятор (чего уж говорить о языках программирования).
    
        Parse arbitrary HTML is like asking Paris Hilton to write an operating system.
        
  - Читаемость сравнимая с различными сортами bnf (по моему мнению даже и лучше). 
  - Даже если вам нужно разобрать линейную (нерекурсивную структуру) parboiled2 (при использовании должных оптимизаций)
    будет работать быстрее регулярных выражений. Данные получены
    [отсюда](https://groups.google.com/forum/#!msg/parboiled-user/XATcJRLTXjA/XSmf3n6gZSwJ)

        Бенчмарк:
          parboiled2 (warmup): 1621.212ms
          parboiled2: 409.162ms
          parboiled2 with better types (warmup): 488.919ms
          parboiled2 with better types: 134.676ms
          regex (warmup): 621.95ms
          regex: 620.379ms

  - В отличии от генераторов парсеров, таких как Antlr вы освобождены от (как бы это банально не звучало) генерации java
    кода парсера, который надо в последствии скармливать компилятору. Весь код в parboiled пишется на scala, поэтому вы
    получаете подсветку синтаксиса и проверку типов из коробки, а так же отсутствие дополнительных операций над файлами
    грамматик.

  - Скаловские парсер-комбинаторы почти идеальны, если вас не смущает скорость их работы. Я не проводил оценку
    производительности, однако Mathias Doenitz (один из разработчиков библиотеки) проводил. Согласно его данным:
    
      * parboiled1 быстрее чем parser-сombinators
      * parboiled2 быстрее чем parboiled1
      * 'быстрее чем' транзитивно :)

  - В отличии от Language Workbenches, Parboiled это маленькая и простая в использовании библиотека. Вам не нужно
    скачивать плоходокументированного и тормозящего монстра, тратить часы драгоценной жизни на изматывающее общение с
    UI: поиск нужных менющек и кнопочек, всего-навсего для построения небольшого DSL. Да, вы не получите на все готоый
    текстовый редактор из коробки, и возможно вам придется самостоятельно писать плагины для текстовых редакторов.
    Однако parboiled вполне достойная альтернатива для маленьких предметно-ориентированных языков.

  - parboiled успешно зарекомендовал себя во 
    [многих проектах](https://github.com/sirthias/parboiled/wiki/Projects-using-parboiled).

  Небольшой benchmark проведенный Александром Мыльцевым (разработчиком библиотеки) взято 
  [отсюда](http://myltsev.name/ScalaDays2014/#/), показывает что скорость разбора приближается к "древним магическим
  парсерам эльфийской работы".

### Parboiled2 vs ручных Json парсеров
  
                  бенчмарк    mc линейное время выполнения
      Parboiled1JsonParser 85.64 ==============================
      Parboiled2JsonParser 13.17 ====
                  Argonaut  7.01 ==
              Json4SNative  8.06 ==
             Json4SJackson  4.09 =


## Новые возможности Parboiled2

  - Parboiled2 решает ряд детских болезней первой версии
    * Решена так называемая Rule7-problem. Для этого была использована библиотека shapeless с ее знаменитыми HListами
      Теперь одно правило может оперировать большим количеством значений на стеке.
    * Добавлены недостающие конструкции. Pb1 нельзя было указать динамическое количество повторений для nTimes. Для
      этого приходилось использовать
      правило oneOrMore, Что не давало требуемой точности при описании грамматики.
    * Встроенные примитивные терминалы. Появился класс CharPredicate, который содержит такие поля как AlphaNumeric, Hex,
      Printable, Visible и другие. Многие пользователи pb1 писали стандартную библиотеку.
    * Добавлена возможность расширения и сужения предиката. Раньше возникала потребность исключить несколько символов из
      правила. Например нам нужны все видимые символы, кроме '=' и ']'. Теперь это с легкостью можно сделать. А не
      создавать "белый список" символов.
  - Parboiled2 использует дополнительную зависимость: библиотеку shapeless.
  - Parboiled2 использует макросы, это позволяет генерировать грамматику на этапе компиляции, а не в рантайме, как это
    сделано для parboiled1. Это многократно увеличивает производительность вашего парсера, и увеличивает количество
    проверок. В связи с этим блок 'rule' стал обязательным. В некоторых случаях код корректно работает без него.
    Теперь это не так.
  - Улучшена система отчета об ошибках
  - Поддержка scala.js. Демо проект представел [здесь](https://github.com/alexander-myltsev/parboiled2-scalajs-samples).
  - Поддержка [Base64 строк]
   (https://github.com/sirthias/parboiled2/blob/v2.0.0-RC1/parboiled/src/main/scala/org/parboiled2/Base64Parsing.scala).


# Как работать с библиотекой
Далее вашему вниманию будет представленно небольшое руководство о том, как работать с данной библиотеки. Начнем же мы
конечно с простого.

Для начала добавим библиотеку в classpath



# Error reporting
TODO

# Тестирование
TODO


# Миграция
Данный раздел посвящен миграции. Процесс не сложный, но время занимает. Поэтмоу я постарался хотя бы чуточку сэкономить
ваше время, и описал основные тезисы в разделе:

## Стратегия
Для того чтобы избежать конфликтов с первой версией. Parboiled2 использует другой classpath `org.parboiled2`, тогда
как classpath для первой версии `org.parboiled`. Maven group-id однако остался `org.parboiled`
Благодаря этому можно иметь обе зависимости в одном проекте, и осуществлять постепенный переход на новую версию.

## Parser теперь не trait, а абстрактный класс.
Traits - удобнейшее средство для композиции програмных компонентов. И многие разр


# Workaroundы для пользователей parboiled1
TODO

## Indentation based grammars
PEG не умеют разбирать грамматики, зависимые от отступов (потому что у PEG) нет лексера.
https://github.com/sirthias/parboiled/wiki/Indentation-Based-Grammars

## Ограничение на 7 правил.
Данная проблема решается использованием Кортежа, вместо одного Resulting rule.
Вот пример:




# Наиболее часто встречающиеся проблемы

## Квотированные строки
TODO

## (Indentation based grammars)

## Парсер на сайдэффектах
TODO


# Best practices
В этом разделе я раскажу о прописных истинах работающих для любого парсер комбинатора, а так же нюансах специяичных для
Parboiled

## Пишите модульные тесты
Банальный совет, которым многие пренебрегают. Парсер не так сложно протестировать, как, скажем IO: Вам не нужны
Mock-объекты и другие ухищрения для этой рутинной, но очень ценной работы. У нас была целая инфраструктура парсеров. И
поверьте, первое что я делал при поиске ошибок - садился и писал тесты, в случае их отсутствия. 

## Не пишите больших парсеров
Разделяйте ваши парсеры, на подпарсеры. Каждый компонент должен делать что-то вполне определенное. Например если вы
парсите LogEvent, у которого опредено поле Timestamp (особенно если этот Timestamp соответствует какому-нибудь Rfc).
Не поленитесь и вынесите его отдельно.

  - Во-первых это уменьшит код вашего основного прасера, и сделает его нагляднее
  - Во-вторых это заметно облегчит тестирование. Вы покроете модульными тестами ваш сабпарсер. А после этого приступите
    к разработке главного парсера.
    
## Не делайте больших правил
Правила должны быть максимально компактными, но не компактней. Чем меньше ваши правила, тем легче найти ошибку в
грамматике. Это спасало.

## Отправляйте case objects вместо строк в Value stack
Данный совет можно отнести и к оптимизациям, Потому что заставляет парсер работать быстрее. 
Отправляйте в Value stack значимые объекты, а не строки. Это сделает ваш парсер быстрее а код нагляднее.

Плохо:

    def logLevel = rule {
      capture("info" | "warning" | "error") ~ ':’
    }

Хорошо:

    def logLevel = rule {
        “info:” ~ push(LogLevel.Info)
      | “warning" ~ push(LogLevel.Warning)
      | “error" ~ push(LogLevel.Error)
    }



# Оптимизации
Главное при выполнении оптимизаций - своевременность. Это то с чем не стоит спешить. 

## Развертка n.times для n <= 4
Вы можете выиграть в производительности если вместо правила "times" для маленьких n

    rule { 4 times CharPredicate.Digit }

будете использовать правило последовательности "sequence" (оно же тильда)

    import CharPredicate.Digit
    rule { Digit ~ Digit ~ Digit ~ Digit }

Это связано в существующей на момент публикации данной статьи
[проблемой](https://github.com/sirthias/parboiled2/issues/101).


## Ускорение операций со стеком для nTimes
Использование подобной оптимизации при извлечении чисел со стека тоже позволит вам выжать немножко производительности

    def digit4 = rule {
      Digit ~ Digit ~ Digit ~ Digit ~ push(#(charAt(-4))*1000 + #(charAt(-3))*100 + #(charAt(-2))*10 + #(lastChar))
    }


## Используйте ANY, там где хотите видеть CharPredicate.All
TODO:


## Используйте инвертирующий предикат 
TODO




Использованные источники
========================
 - [Юзергруппа](https://groups.google.com/forum/#!topic/parboiled-user/Ygb_M6XU5P8) посвященная Parboiled2 
   Здесь вы можете задать все интересующие вас вопросы. Вам помогут.
 - Презентация Александра Мыльцева [Видео](http://www.youtube.com/watch?v=qZg4D62K4aQ)
 - [Слайды](http://myltsev.name/ScalaDays2014/#/) к презентации Александра [ENG] 
 - Официальная [документация](https://github.com/sirthias/parboiled2/blob/master/README.rst)
 - [Примеры](https://github.com/sirthias/parboiled2/tree/master/examples/src/main/scala/org/parboiled2/examples)
   исходного кода 
