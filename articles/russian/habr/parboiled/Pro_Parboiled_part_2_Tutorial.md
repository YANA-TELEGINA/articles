# Про Parboiled
**Часть 2: Сопоставление текста**

Если вы никогда не работали с Parboiled и из предыдущей статьи так и не поняли, о чём вообще идёт речь, то в этой
статье речь пойдёт об основных правилах сопоставления символов. Все имеющиеся в PB правила в рамках этой статьи мы
рассматривать не будем — для этого есть документация, я всего лишь хочу, чтобы вы чувствовали себя уверенно с нотацией,
используемой в Parboiled.

<cut text="Туториал для Parboiled →">

Для закрепления знаний мы напишем простой распознаватель для несложной грамматики. Распознаватель (recognizer), а не
полноценный парсер, так как он будет только сопоставлять входной текст описанными нами правилам (также называемым
*продукциями*), но не будет извлекать из сопоставленного текста какие-либо значения. Разпознаватель может быть полезным
и сам по себе, так может работать в качестве валидатора: если вход оказался некорректным с точки зрения парсера, он
расскажет, что пошло не так и где. А совсем классным наш распознаватель станет тогда, когда мы узнаем, как извлекать
разобранные значения и причем тут какой-то «value stack». Ну что, поехали?


## Подготовительные работы

Перед началом работы с библиотекой добавим ее в classpath. В maven, например, это делается так:

    <dependency>
        <groupId>org.parboiled</groupId>
        <artifactId>parboiled_2.11</artifactId>
        <version>2.1.0</version>
    </dependency>

Значение `artifactId` недвусмысленно содержит используемую версию языка Scala, а не самого Parboiled. Я использую
Scala 2.11, однако существует соответствующий артефакт и для 2.10.

Теперь напишем парсер, который ничего не делает, что не мешает ему существовать и радоваться жизни:

    import org.parboiled2._

    class UselessParser(val input: ParserInput) extends Parser {
      // Hello cruel world.
    }

Конструкции DSL, а так же ряд полезных класов добавляются в зону видимости всего одной директивой импорта.
Прошу заметить, что наличие параметра `input` в конструкторе является обязательным: это означает, что на каждого нового
набора входных данных нужно создавать новый объект-парсер. Вначале меня это очень сильно пугало, но я перестал бояться,
когда увидел, как быстро оно работает.


## Язык описания правил (Rule DSL)

### Правила для отдельных символов

Итак, когда никчёмный парсер у нас уже имеется, нужно добавить с него несколько правил, в соответствии с которыми он
и будет обрабатывать данные. Если вы работали с Parboiled1, этот раздел можно просто пролистать, так как мои объяснения
могут показаться вам слишком уж подробными.

Начнем мы с терминалов. Это термин будет использоваться в дальнейшем, поэтому определим его так:

> Терминал — это правило, не требующие дополнительных определений, т.е. не использующее других нетривиальных правил.

Правила добавляют прямо внутрь класса парсера и могут использовать как друг друга, так и, при необходимости, правила из
других парсеров. Давайте опишем два простейших правила: одно из них способно распознать некоторый наперёд известный
символ, другое — строку:

    def UselessCharRule   = rule { ch('?') }
    def UselessStringRule = rule { str("hopelessness") }

Каждый раз обозначать свои намерения подобным образом весьма утомительно, но благодаря механизму неявного преобразования
(implicit conversions), можно переписать их короче:

    def UselessCharRule   = rule { 'a' }
    def UselessStringRule = rule { "hopelessness" }

Важно, что строка сопоставляется с точным учётом регистра символов. Если нет необходимости быть такими занудами, можно
использовать готовое правило `ignoreCase` (передаваемая в него строка обязательно должна быть в нижем регистре):

    def UselessStringWithCaseIgnored = rule { ignoreCase("hopelessness") }

Подробнее о правилах (или «продукциях», если вам заумные академические термины вам нравятся больше) будет рассказано
далее. Сейчас же нам необходимо знать, что `Rule0` сопоставляет вход с правилом и говорит, совпало или нет. Все
приведенные выше (и ниже) правила имеют тип `Rule0`. Мы его не указывали потому, что механизм вывода типов языка пока
легко справляется и сам. Но тип можно указать и явно:

    def UselessStringWithCaseIgnored: Rule0 = rule { ignoreCase("hopelessness") }

В Parboiled существуют два особенных терминала, которые по идее должны обрабатываться специальным образом, отличным от
простого текста (поэтому их ещё называют синтаксическими предикатами):

  - `ANY` — любой символы, кроме `EOI`.
  - `EOI` (End of Input) — виртуальный символ-маркер конца ввода, котоый вы обязательно захотите добавить в главное
    правила своего парсера. Определяется `EOI` так:


    val EOI = '\uFFFF'

Несмотря на то, что символ U+FFFF зарезервирован для внутреннего использования стандартом Юникода, на практике он может
запросто встретиться в пользовательском вводе и изменить поведение парсера. Поэтому будьте внимательны с текстом,
который попадает на вход.

Кроме того, если вы не добавите `EOI` в конец цепочки главного правила и при парсинге возникнет ошибка, то о ней вы не
узнаете, так как парсер будет считать, входные данные ещё не закончились и для него пока ещё не поздно всё исправить.
Поэтому, чтобы вы не подали на вход, на выходе вас ожидает бессмысленный Success.

Из правил `chr` и `str` вряд ли можно составить полезный парсер, поэтому первым шагом к осмысленности станет
возможность определять *диапазон* допустимых симовлов. В Parboiled2 это делается очень легко:

    def Digit      = rule { '0' - '9' }
    def AlphaLower = rule { 'a' - 'z' }

Оба эти правила сопоставят за раз максимум один символ (или не сопоставят ни одного). Хотя написать конкретно эти два
правила в PB2 очень просто, делать этого нет необходимости: они уже определены в объекте `CharPredicate`. А вот
Parboiled1 заставлял делать это часто, практически каждый раз, когда вы пишете очередной парсер. Поэтому я носил свою
библиотечку примитивов из проекта в проект (уверен, что не я один так делал). Теперь моя библиотечка заметно
подыстощилась благодаря появлению `CharPredicate`. В него входят, например, следующие правила (думаю, что из названий
будет понятно, каким категориям символов они соответствуют):

 - `CharPredicate.All` (работает почти так же, как `ANY`, но показывает худшую производительность на больших диапазонах
   символов);
 - `CharPredicate.Digit`;
 - `CharPredicate.Digit19`;
 - `CharPredicate.HexDigit` и много других правил.

Кроме того, для символьных предикатов работают правила `except` (`--`) и `union` (`++`), которых не было в PB1. Лично
я от этого отсутствия очень страдал: приходилось замыкать правило «с другой стороны», перечисляя полностью черный или
белый список символов в зависимости от ситуации).

    // Сопоставит любой печатный символ, если это не кавычка. И будет работать
    // медленно, так как операция вычитания из множества будет выполнять каждый
    // раз когда применяется правило. Стоит вынести определение символьного
    // предиката в отдельную константу.
    def AllButQuotes = rule { CharPredicate.Visible -- "\"" -- "'" }

    // Вполне себе сойдет для определения идентификатора. Обратите внимание, как
    // AlphaNum объединяется с нижним подчергиванием.
    def ValidIdentifier = rule {
      CharPredicate.Alpha ~ zeroOrMore(CharPredicate.AlphaNum ++ "_") }

Полезно будет рассказать ещё о двух правилах: `anyOf` и `noneOf`. Они очень похожи на `except` и `union`, но работают
на всём пространстве символов `ANY`. И самое главное: в этом пространстве они работают быстрее. Эти функции могут
принимать на вход строку, состоящую из перечислений символов. Например:

    // Определит, является ли символ одной из арифметических операций.
    def ArithmeticOperation = rule { anyOf("+-*/^") }

    // Сопоставит всё, кроме перечисленных пробельных символов и EOI.
    def TheCurseOf32 = rule { noneOf(" \t\n") }

Итак, что же выбрать: `anyOf`/`noneOf` или `CharPredicate`? Заранее предопределенный символьный предикат будет работать
быстрее для 7-битных символов ASCII. «Заранее предопределенный» написано не просто так, и в разделе «Best Practices»
части 4 будет рассказано, почему. Однако для очень больших символьных диапазонов `CharPredicate` ведёт себя откровенно
плохо, и тогда на помощь должны прийти `anyOf` и `noneOf`.

### Цепочки правил

#### N.times

Сопоставлять единичные символы не интересно, поэтому перейдем к более сложным правилам. Начнём с `times`, которое
позволяет сопоставить вполне определённое количество идущих подряд правил.

    def BartLearningParboiled = rule { 100 times "I will never write a parser again" }

Некоторые грамматики требуют жесткого диапазона числа повторений, например [от двух до пяти][korn]. В новом Parboiled
это можно легко устроить:

    def FutureOfCxx = rule { 'C' ~ (2 to 5) times '+' }

[korn]: http://www.chukfamily.ru/Kornei/Prosa/Ot2do5/Ot2do5.htm

А в старом — существует правило `nTimes`, которое, однако, требует указания точного числа повторений. Если же точное
значение заранее не известно, то приходилось прибегать к следующим двум правилам.


#### zeroOrMore

Внимательный читатель уже замечал это правило в примерах и оно ему, скорее всего, хорошо знакомо: в регулярных
выражениях точно такая же операция обозначается звёздочкой, а любители академической терминологии, кроме того, знают,
что она называется [звездой Клини][kstar]. В любом случае, использовать это правило очень просто:

    def Whitespace          = rule { anyOf(" \n\t") }
    def OptionalWhitespaces = rule { zeroOrMore(WhiteSpace) }

[kstar]: https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D0%B5%D0%B7%D0%B4%D0%B0_%D0%9A%D0%BB%D0%B8%D0%BD%D0%B8


#### oneOrMore

Правило, похожее на предыдущее. Оно делает почти то же самое, что и `zeroOrMore`, но требует, чтобы хотя бы одно
повторение присутствовало во входных данных. Идентично плюсу Клини для регулярных грамматик.

    def UnsignedInteger = rule { oneOrMore(CharPredicate.Digit) }


#### separatedBy

Часто приходится иметь дело со случаем, когда множество элементов записываются подряд через определённый разделитель:
это CSV, и перечисление аргументов функции через запятую, и многие другое. В Parboiled2 парсинг таких
последовательностей делается легко и непринужденно:

    def CommaSeparatedNumbers rule { oneOrMore(UnsignedInteger).separatedBy(",") }

Однако, первая версия использует для этого менее элегантный синтаксис.


#### Операция последовательности (~)

Для указания того факта, что два правила должны сопоставиться последовательно: одно сразу за другим используется
оператор `~`. В регулярных выражениях нет необходимости в подобном операторе, там этот факт записывается
непосредственным образом, так же, как и в BNF. Для примера напишем (предельно упрощённое) правило для сопоставления с
форматом адреса электронной почты:

    def UserName = rule { oneOrMore(CharPredicate.AlphaNum ++ "_-+.") }
    def HostName = rule { oneOrMore(CharPredicate.AlphaNum ++ "_-.")

    def ReallySimplifiedEmail = rule { UserName ~ "@" ~ HostName }

> **Предупреждение:** Как и проверка регулярными выражениями, этот парсер отсечёт много легитимных электронных адресов
> и пропустит много некорретных, поэтому его лучше не использовать в продакшне. С другой стороны, при помощи Parboiled
> легко можно написать более продвинутый парсер, и он не будет выглядеть как вот [это регулярное выражение][re-email].

[re-email]: http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html


#### «Необязательное» правило (optional)

Если бы существовало правило `zeroOrOne`, то это и был бы `optional`: либо есть одно вхождение, либо вхождений нет
совсем. Давайте разберем следующий пример: в разных семейства операционных систем маркер конца строки кодируется
по-разному. Например, в Unix-подобных операционных системах нужен только символ '\n', тогда как в Windows исторически
используется последовательность из двух симвловов: '\r' и '\n'. И если мы хотим обрабатывать текст, созданный в
любой из этих систем, то может использовать следующее правило для конца строки:

    def NewLine = rule { optional('\r') ~ '\n' }


#### Упорядоченный выбор (Ordered Choice)

Аналог оператора `|` в регулярных выражениях, неспроста называемый *упорядоченным* выбором. Предположим, что нам нужно
распознать число, у которого может быть знак, а может и не может. Знак бывает двух типов: положительный и отрицательный,
разберемся сначала с ним:

    def Signum = rule { '+' | '-' }

Далее, знак может вовсе отсутствовать в записи положительного числа:

    def MaybeSign = rule { optional(Signum) }

А само число число тогда представится в виде последовательности из знака числа и его модуля — числа без знака:

    def Integer = rule { MaybeSign ~ UnsignedInteger }

Порядок перечисления вариантов в правиле `Signum` имеет значение: выбирается самый первый из подошедших вариантов.
Это исключает возможность появление неоднозначности у вашей грамматики. И да, так работают все PEG-парсеры. Так, если
у вас стоит задача сопоставления операций языка C, начинать перечисление нужно с самых длинных, чтобы они сопоставились
первыми (так предписывает стандарт). Упрощённо, правило может выглядеть, например, так:

    def COperators = rule {
      "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "^=" | "|=" | "<<=" | ">>=" |
      "<<" | ">>" | "<=" | ">=" | "==" | "!=" |
      "||" | "&&" | "->" | "++" | "--" |
      "<"  | ">"  | "+"  | "-"  | "&"  | "|" | "." |
      "*"  | "/"  | "!"  | "~"  | "^"  | "=" | ","
    }

Порядок перечислений может быть самым различным, но нужно обеспечить, чтобы в нём `+` всегда шёл после `+=` и `++`,
а `<` — после `<=` и `<<` (а `<<`, в свою очередь, после `<<=`). В противном случае может случиться, что составной
оператор присваивания `<<=` распарсится в последовательность [`<=`, `=`], а то и вовсе [`<`, `<`, `=`].

Если правило выбора становится избыточно сложным и не хочется полагаться на порядок его элементов, стоит сгруппировать
их по общим префиксам (факторизовать парсер):

    def COperators = rule {
      ("+" ~ optional("=" | "+")) |
      ("<" ~ optional("=" | ("<" ~ optional("=")))) | ...
    }

Заметим, однако, что при подобном описании парсер не сможет автоматически учитывать приоритеты операторов, для этого
придётся прибегнуть к более изощрёным правилам.


### Синтаксический сахар

Для `optional`, `oneOrMore` и `zeroOrMore` существует синтаксический сахар, позволяющий сделать определения ещё короче:
`.?`, `.+` и `.*`. Пожалуйста, используйте их мудро (или хотя бы не говорите никому, что это я вам про них рассказал):
если их навертеть, ваши правила будут читаться немногим лучше, чем регулярки. Перепишем парсер знаковых чисел с
использованием «сахара»:

    def UnsignedInteger = rule { CharPredicate.Digit.+ }
    def SignedInteger   = rule { (+ | -).? ~ UnsignedInteger }

И добавим поддержку массивов из целых чисел:

    def IntegerArray = rule {
      SignedInteger * (OptionalWhitespaces ~ ',' ~ OptionalWhitespaces)
    }

    // То же самое, но при этом лучше читается.
    def IntegerArray = rule {
      zeroOrMore(SignedInteger) separatedBy (OptionalWhitespaces ~ ',' ~ OptionalWhitespaces)
    }


### Запуск парсера

Для того, чтобы заставить написанный парсер сделать хоть что-то полезное, нужно вызвать метод `run` его главного
(корневого) правила (если вы пишете юнит-тест для парсера, то может иметь смысл вызывать этот метод и для других
правил). Скобочки после метода при этом обязательны.

Давайте заставим работать наш бесполезный парсер, умеющий сопоставлять только одну строковую константу. Итак, если
наш парсер определён следующим образом (не забываем про `EOI`):

    import org.parboiled2._

    class UselessParser(val input: ParserInput) extends Parser {
      def UselessStringRule: Rule0 = rule { ignoreCase("hopelessness") ~ EOI }
    }

Теперь где-нибудь в другом месте создадим два экземплляра парсеров и подадим им на вход разные данные:

    val p1 = new MyParser("Hopelessness")
    val p2 = new MyParser("Happiness")

    // по-умолчанию возвращают scala.util.Try
    p1.MyStringRule.run()
    p2.MyStringRule.run()

Прогон правил в Parboiled2 намного проще чем в Parboiled1, для которого существует целый зоопарк раннеров (parser
runners), которые приходится дополнительно вызывать. За более подробной информацией прошу в раздел «Отчеты об ошибках»
части 4.


### Вложенные структуры данных

Разбор рекурсивных структур — это то, что может Parboiled и не могут регулярные выражения. В Parboiled это получается
естественно и непринужденно, что мы сейчас и продемонстрируем на последующих примерах. Единственное дополнительное
усилие которое от вас требуется — явно объявить тип правил, участвующих в рекурсии.

Разбор рекурсивных структур обычно иллюстрируют на примере калькулятора арифметических выражений. По моему мнению,
пример совершенно не нагляден. Поэтому мы рассмотрим вымышленный формат конфигурационных файлов, состоящий из
именованных блоков, содержащих пар «ключ—значение».


#### Формат BKV (Block-Key-Value)

В качестве примера будет использоваться формат «BKV», который был придуман специально для этого туториала. Он
вдохновлялся форматом [HOCON][hocon]. И, собственно является его подмножеством. BKV состоит из пар ключ-значение и
блоков, внутри которых могут размещаться пары. Выглядит это примерно так:

[hocon]: https://github.com/typesafehub/config/blob/master/HOCON.md

    server.name = "webserver"
    server {
      port = "8080"
      address = "192.168.88.88"

      settings {
        greeting_message = "Hello!\n It's me!"
      }
    }

Как видите, формат прост и незатейлив, хотя строки с экранированием (escaping) могут напугать тех, кто никогда не
писал парсеры. Экранирование очень часто встречается при синтаксическом разборе, поэтому мы обязательно и в
подробностях его рассмотрим.


##### Экранированные строки

Для того чтобы при синтаксическом разборе не иметь проблем с пробельными и непечатными символами, в большинстве
грамматик строки заключаются в двойные или одинарные кавычки (или их некое подобие, например могут использоваться
открыввющие и закрывающие угловые скобки). Пробельные, непечатные символы и кавычки - экранируются.

Основные компоненты строк с экранированием:

 - Символ(ы) открывающие и закрывающиие строку (в нашем случае двойная кавычка)
 - Символ экранирования - (в нашем случае /)
 - набор символов-мнемоник для обозначения непечатных символов (n,a,f...)

Давайте сначала попробуем описать правило для квотированной строки без экранирования:

    def DumbQuotedString = rule {
      '"' ~ zeroOrMore(AllowedChar) ~ '"'
    }

Поскольку пустые строки тоже возможны, мы используем правило `zeroOrMore` для символов помещенных между кавычек.
Очевидно, что двойная кавычка в перечень допустимых символов не входит. Что разрешено? Все что не запрщено. Поэтому для
нашего случая список разрешенных символов выглядит так:

    def AllowedChar = rule {
       noneOf("\"") // Все что не кавычка
    }

Без двойной кавычки жить можно, но сложно. Но что будет если мы ее добавим? Парсер ее встретит и подумает что строка
закончилась и взорвется с сообщениями об ошибке скорее всего на следующем символе может быть чуть позже.

Символ экранирования предупреждает парсер о том, что следущий символ особенный. Алгоритм выглядит таким образом:
парсер ожидает один из разрешенных символов или экранированную последовательность. Экранированная последовательность
состоит из символа экранирования и следующим за ним оператором выбора одного из символов.

    def AllowedChar = rule {
      noneOf("\"\\") | EscapeSequence
    }

    // В нашем случае мы используем anyOf
    def EscapeSequence = rule {
      '\' ~ anyOf("\"\\")
    }

Разобравшись с механизмом можно реализовать набор конечных правил для экранирования. Для этого предлагают создать
выделенный трейт:

    import org.parboiled2._

    object QuotedStringSupport {
      val CharsToBeEscaped = "abfnrtv\\\""
      val BackSlash = '\\'
      val AllowedChars = CharPredicate.Printable -- BackSlash -- '"'
    }

    trait QuotedStringSupport { this: Parser =>
      import QuotedStringSupport._

      def QuotedString: Rule0 = rule {
        '"' ~ QuotedStringContent  ~ '"'
      }

      def QuotedStringContent: Rule0 = rule {
        oneOrMore(AllowedChars | DoubleQuotedStringEscapeSequence)
      }

      def DoubleQuotedStringEscapeSequence = rule {
        '\\' ~ anyOf(CharsToBeEscaped)
      }
    }

Разобравшись со строками и сохранив их в отдельный трейт, перейдем к самому формату.


#### Вспомогательные терминалы

В написании парсеров существует два подхода: "от общего к частному" и "от частного к общему". И обычно грамматики
описываются согласно первому. Это туториал, поэтому начнем с деталей по-мельче, затем обобщим. Первыми на очереди у нас
будут вспомогательные терминалы: пробельные символы, и символьные предикаты. В нашем случае пробелами будут являться
следующие символы: `' '`, `\n` и `\t`. Конечно, существует большее число пробельных символов, но в примере мы
ограничимся описанными выше.

Объявить пробельные символы можно следущими способами:

Начем описание со вспомогательных элементов, а именно, с пробелов. В нашем случае пробелами будут являться символы:
' ', '\n' и '\t'. Конечно же, пробельных символов в природе существует куда больше, но в примере мы ограничимся тремя.
Разобраться с пробелами можно разными способами:
Мы воспользуемся последним (найти его определение можно выше). Так же объявим правила для необязательных пробелов.

 - перечислить символы через оператор упорядоченного выбора;
 - объявить свой `CharPredicate`, содержащий эти три символа;
 - использовать `anyOf`.

Мы воспользуемся последним. При этом учтём, что в некоторых местах пробелов может быть несколько, в некоторых их может
не быть вовсе, а кое-где пробелы должны быть обязательно (но нашему формату обязательные пробелы не требуются):
Используемому формату обязательные пробелы не требуются.

    val WhitespaceChars = " \n\t"
    def Whitespace      = rule { oneOrMore(anyOf(WhitespaceChars)) }
    def OptWhitespace   = rule { zeroOrMore(anyOf(WhitespaceChars)) }

Правило, описывающее перевод строки мы объявляли ранее:

    def NewLine = rule { optional('\r') ~ '\n' }

В нашем случае Ключ и Имя блока представляют собой валидный идентификатор для большинства языков программирования.
Идентификатор может содержать цифры, буквы английского алфавита (строчные и заглавные), а так же символ подчеркивания
`_` и точку. Перед тем как объявлять ключ, объявим предикат, описывающий Идентификатор. (Аналогичные правила будут
применяться для имени блока)

    val Identifier = CharPredicate.AlphaNum ++ "_" ++ "."

    // Являются идентификаторами
    val KeyCharacter = Identifier
    val BlockNameCharacter = Identifier

Объявим так же символы начала и конца блока:

    val BlockBeginning  = '{'
    val BlockEnding     = '}'

Все необходимые вспомогательные терминалы у нас объявлены. Перейдем к описанию пар.


##### Пары «ключ—значение»

Теперь перейдём к синтаксису пары ключ–значение. Потребуем, чтобы ключ представлял собой валидный идентификатор, как
принято в большинства языков программирования: ему позволено содержать буквы английского алфавита (строчные и
заглавные), цифры, а также символ подчеркивания. Вынесем допустимые символы в отдельные предикаты и определим правило:

    val KeyChar      = CharPredicate.AlphaNum ++ '_'
    val KeyCharFirst = KeyChars -- CharPredicate.Digit

    def Key = rule { KeyCharFirst ~ zeroOrMore(KeyChar) }

А вот со значением нам будет немного проще (для этого нам всего-то нужно подмешать написанный нами ранее трейт):

    def Value = rule { DoubleQuotedString }

Теперь опишем правило для пары ключ-значение. Стоит еще раз напомнить о том, что Parboiled является PEG, из этого
следует, что нам постоянно нужно помнить о пробелах, и сообщать правилу о местах, где они могут встречаться.

    def KeyValuePair = rule { Key ~ MayBeWS ~ "=" ~ MayBeWs ~ Value }

На данном этапе мы написали простой распознаватель, исходный код которого находится [тут][bkv-gist]. Сопоставлять
значения на практике приходится весьма редко. А вот захватывать их — практически каждый раз. Теперь перейдем к
объявлению рекурсивных структур.

[bkv-gist]: https://github.com/ppopoff/parboiled-talk


##### Вложенность

Теперь мы реализщуем блок, который может хранть одну или несколько пар ключ-значение или другие блоки. Для начала, нужно
"стереть" различия между блоками и парами ключ значения. И те и те будут являться узлами (Nodes) дерева.
Описанное выше иллюстрируется следующим кодом:

    // Тип правила обязателен к указанию!
    def Node: Rule0 = rule { KeyValuePair | Block }

так как Блок, а так же корневая структура состоят из списка узлов, нам нужно объявить правило для этго списка:

    def Nodes = rule {
      MayBeWS ~ zeroOrMore(Node).separatedBy(Newline ~ MayBeWS) ~ MayBeWS
    }

Ноды разделяются символом перевода строки, пробелы могут быть перед списоком, после, и перед каждым блоком или парой.
давайте определим имя блока:

    def BlockName = oneOrMore(BlockNameCharacter)

Все необходимое для объявления блока у нас уже есть, поэтому объявим имя блока:

    def Block = rule { BlockName ~ "{" ~ Nodes ~ "}" }

Заметьте, что Block ссылается на написанное нами правило Nodes, которое будет ссылаться на правило Node. Здесь возникает
цикл. Поэтому нам необходимо явно указать тип правила, успокоив и обнадежив Parboiled. В нашем случае тип правила будет
Rule0. Более подробно о правилах будет рассказано в следующей статье.

У нас все есть, не хватает только точки входа, или корня (Root). Корень представляет собой список узлов. Поэтмоу
используем правило для списка узлов и завершим его символом `EOI`:

    def Root: Rule0 = rule { Nodes ~ EOI }

На данном этапе мы написали простой распознаватель. Сопоставлять значения на практике приходится весьма редко.
А вот захватывать их "каждый раз" приходится постоянно. В следующей статье я расскажу вам "захватывающие истории", о
типах правил и чем они отличаются. Мы доведем распознаватель до состояния работоспособного парсера.
